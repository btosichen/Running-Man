<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Ê†°ÂúíËø∑ÂÆÆÈÄÉËÑ´ (ÁÇ∏ÂΩàËàáË¶ñËßíÈéñÂÆöÁâà)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial Black', 'Segoe UI', Tahoma, sans-serif;
            background-color: #111;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 177.78vh;
            aspect-ratio: 16/9;
            background-color: #87CEEB;
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            z-index: 5;
        }

        #mobile-controls {
            position: absolute;
            bottom: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20;
        }

        .control-zone {
            pointer-events: auto;
            position: absolute;
            bottom: 5%;
        }

        /* Â∑¶ÂÅ¥ÊñπÂêëÈçµÂçÄÂüü */
        .d-pad-container {
            left: 5%;
            width: 22%;
            aspect-ratio: 1/1;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 2%;
        }

        /* Ë¶ñËßíÈéñÂÆöÊåâÈàï‰ΩçÁΩÆ */
        .camera-lock-container {
            position: absolute;
            left: 5%;
            bottom: 30%; /* Âú®ÊñπÂêëÈçµ‰∏äÊñπ */
            width: 8%;
            aspect-ratio: 1/1;
            pointer-events: auto;
        }

        .skill-container {
            right: 5%;
            width: 12%;
            aspect-ratio: 1/1;
            display: flex;
            justify-content: center;
            align-items: center;
            bottom: 8%;
        }

        .touch-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 15%;
            color: white;
            display: flex; justify-content: center; align-items: center;
            font-size: 2vw;
            backdrop-filter: blur(4px);
            transition: transform 0.1s;
            touch-action: manipulation; 
        }

        .touch-btn:active, .touch-btn.pressed {
            background: rgba(255, 200, 0, 0.6);
            border-color: rgba(255, 255, 0, 0.9);
            transform: scale(0.9);
        }

        .btn-up { grid-column: 2; grid-row: 1; border-radius: 10px 10px 0 0; }
        .btn-left { grid-column: 1; grid-row: 2; border-radius: 10px 0 0 10px; }
        .btn-down { grid-column: 2; grid-row: 3; border-radius: 0 0 10px 10px; }
        .btn-right { grid-column: 3; grid-row: 2; border-radius: 0 10px 10px 0; }
        .btn-center { grid-column: 2; grid-row: 2; background: rgba(0,0,0,0.1); border: none; }

        .btn-skill {
            width: 100%; height: 100%;
            border-radius: 50%;
            background: rgba(255, 50, 50, 0.4);
            border: 3px solid rgba(255, 150, 150, 0.6);
            font-size: 4vw;
            box-shadow: 0 0 2vw rgba(255, 0, 0, 0.4);
        }
        .btn-skill:active, .btn-skill.pressed {
            background: rgba(255, 50, 50, 0.9);
            transform: scale(0.9);
        }

        /* Ë¶ñËßíÊåâÈàïÊ®£Âºè */
        .btn-lock {
            width: 100%; height: 100%;
            border-radius: 50%;
            background: rgba(50, 50, 200, 0.4);
            border: 2px solid rgba(100, 100, 255, 0.6);
            font-size: 3vw;
        }
        .btn-lock.locked {
            background: rgba(200, 50, 50, 0.6);
            border-color: rgba(255, 100, 100, 0.8);
        }

        #hud {
            padding: 2%;
            display: flex; justify-content: space-between; align-items: flex-start;
            color: #fff; text-shadow: 0.2vw 0.2vw 0 #000;
            font-size: 2.5vw;
        }
        
        #health-container {
            width: 20vw; height: 3vw;
            background: #333; border: 0.3vw solid #fff;
            border-radius: 1.5vw; overflow: hidden;
            margin-top: 0.5vw; position: relative;
        }
        #health-bar { width: 100%; height: 100%; background: #e74c3c; transition: width 0.2s; }
        #health-text {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.5vw; text-shadow: 1px 1px 0 #000;
        }

        #status-effects { margin-top: 0.5vw; display: flex; gap: 0.5vw; }
        .effect-badge {
            padding: 0.5vw 1vw; border-radius: 0.5vw; font-size: 1.5vw;
            font-weight: bold; text-shadow: 1px 1px 0 #000; animation: pulse 1s infinite;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        #input-debug { display: none; }

        #blocker {
            position: absolute; width: 100%; height: 100%; top: 0; left: 0;
            background-color: rgba(0,0,0,0.85); backdrop-filter: blur(8px);
            display: flex; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 30;
        }
        #instructions {
            width: 70%; padding: 3vw;
            background: linear-gradient(135deg, #ffffff, #ecf0f1);
            border-radius: 2vw; text-align: center; color: #2c3e50;
            box-shadow: 0 2vw 5vw rgba(0,0,0,0.6); border: 0.5vw solid #fff;
        }
        h1 { margin: 0 0 1vw 0; color: #e74c3c; font-size: 4vw; }
        p { font-size: 2vw; margin: 1vw 0; color: #555; font-weight: bold; }
        
        #start-btn {
            background: #27ae60; color: white; font-size: 3vw; padding: 1.5vw 5vw;
            border: none; border-radius: 1vw; cursor: pointer; margin-top: 2vw;
            box-shadow: 0 0.5vw 0 #219150; font-weight: 900;
            touch-action: manipulation;
        }
        #start-btn:active { transform: translateY(0.5vw); box-shadow: none; }

        #result-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 10, 10, 0.95); color: white; z-index: 40;
            flex-direction: column; align-items: center; justify-content: center;
            text-align: center; pointer-events: auto;
        }
        button.action-btn {
            padding: 1.5vw 4vw; font-size: 2.5vw; color: white; border: none; border-radius: 1vw;
            cursor: pointer; margin-top: 2vw; box-shadow: 0 0.5vw 0 rgba(0,0,0,0.2);
            font-weight: bold;
        }
        .btn-next { background: #3498db; box-shadow: 0 0.5vw 0 #2980b9; }
        .btn-retry { background: #e74c3c; box-shadow: 0 0.5vw 0 #c0392b; }
        .btn-next:active, .btn-retry:active { transform: translateY(0.5vw); box-shadow: none; }
        
        .win-text { color: #2ecc71; font-size: 6vw; text-shadow: 0.5vw 0.5vw 0 #27ae60; }
        .lose-text { color: #e74c3c; font-size: 6vw; text-shadow: 0.5vw 0.5vw 0 #c0392b; }
        .warning-text { color: #e74c3c; font-size: 2vw; margin-top: 0.5vw; display: block; font-weight: bold; text-shadow: 1px 1px 0 #000; animation: blink 1s infinite;}
        @keyframes blink { 0% {opacity: 1;} 50% {opacity: 0.5;} 100% {opacity: 1;} }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="ui-layer">
            <div id="hud">
                <div>
                    <div style="color: #f1c40f;">Level <span id="level-num">1</span> / 100</div>
                    <div id="time-display">‚è∞ 05:00</div>
                    <div id="status-effects"></div>
                    <div id="enemy-warning" class="warning-text">‚ö†Ô∏è Êïµ‰∫∫ÂÖ®Èù¢ÁãÇÊö¥ÔºÅ</div>
                </div>
                <div style="text-align: right;">
                    <div id="status" style="font-size: 2vw;">Â∞ãÊâæÁ∂†Ëâ≤ÂÖâÊü±</div>
                    <div id="health-container">
                        <div id="health-bar"></div>
                        <div id="health-text">HP: 100/100</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="mobile-controls">
            <div class="camera-lock-container">
                <button class="touch-btn btn-lock" id="btn-camera-lock">üîì</button>
            </div>
            <div class="control-zone d-pad-container">
                <div class="touch-btn btn-center"></div>
                <div class="touch-btn btn-up" id="btn-up">‚ñ≤</div>
                <div class="touch-btn btn-left" id="btn-left">‚óÄ</div>
                <div class="touch-btn btn-down" id="btn-down">‚ñº</div>
                <div class="touch-btn btn-right" id="btn-right">‚ñ∂</div>
            </div>
            <div class="control-zone skill-container">
                <div class="touch-btn btn-skill" id="btn-skill">üí•</div>
            </div>
        </div>

        <div id="blocker">
            <div id="instructions">
                <h1 id="menu-title">Ê†°ÂúíÁîüÂ≠òÈÄÉËÑ´</h1>
                <p id="menu-subtitle">100 Â±§ÁÑ°Áõ°ÊåëÊà∞ÔºÅ</p>
                <hr style="border: 2px dashed #ddd; margin: 2vw 0;">
                <p>Â∑¶ÊâãÁßªÂãï &nbsp; Âè≥ÊâãÈ≠îÊ≥ï</p>
                <p>‚ö°Âä†ÈÄü &nbsp; ‚ùÑÔ∏èÁ∑©ÈÄü &nbsp; ‚ù§Ô∏èË£úË°Ä</p>
                <p style="color:#e74c3c; font-size: 1.8vw;">Ê≥®ÊÑèÔºöÊïµ‰∫∫ÊúÉÊäïÊì≤ÂÆöÊôÇÁÇ∏ÂΩàÔºÅ</p>
                <br>
                <button id="start-btn">ÈªûÊìäÈñãÂßã</button>
            </div>
        </div>

        <div id="result-screen">
            <div id="result-title" class="win-text"></div>
            <p id="result-message" style="font-size: 3vw; margin: 2vw; color: #ddd; font-weight: bold;"></p>
            <button id="action-btn" class="action-btn" onclick="handleAction()">‰∏ã‰∏ÄÈóú</button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- ÂÖ®ÂüüËÆäÊï∏ ---
        let camera, scene, renderer;
        let worldGroup = new THREE.Group();
        
        let playerStats = { hp: 100, maxHp: 100, speedMulti: 1.0, invincible: 0 };
        const PLAYER_BASE_SPEED = 250.0;
        const ROTATE_SPEED = 2.5;
        let weaponMesh;
        let projectiles = [];
        let grenades = []; // Êñ∞Â¢ûÁÇ∏ÂΩàÈô£Âàó
        
        let moveForward = false, moveBackward = false, rotateLeft = false, rotateRight = false;
        let cameraLocked = false; // Ë¶ñËßíÈéñÂÆöÁãÄÊÖã
        
        let enemies = [];
        let items = [];
        let maze = [];
        let exitPosition = new THREE.Vector3();
        
        let prevTime = performance.now();
        const TILE_SIZE = 25;
        const WALL_HEIGHT = 20;
        let gameActive = false;
        let timeLeft = 0;
        let timerInterval;
        let enemySpeedMulti = 1.0;

        let currentLevel = 1;
        let currentLevelData = {};

        // --- Èü≥ÊïàÁÆ°ÁêÜÂô® (Âº∑ÂåñÁâà) ---
        class SoundManager {
            constructor() { 
                this.ctx = null; 
                this.bgmTimer = null;
                this.bgmStep = 0;
                this.isPlaying = false;
                this.nextStepTime = 0;
            }
            
            init() {
                try {
                    if(!this.ctx) {
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        this.ctx = new AudioContext();
                    }
                    if(this.ctx.state === 'suspended') this.ctx.resume();
                    this.isPlaying = true;
                    this.startAmbience();
                    this.startBGM();
                } catch (e) {
                    console.log("Audio warning:", e);
                }
            }

            stop() {
                this.isPlaying = false;
                if(this.bgmTimer) clearTimeout(this.bgmTimer);
            }

            playTone(freq, type, duration, vol = 0.1, slideTo = null) {
                if (!this.ctx) return;
                try {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                    if (slideTo) osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + duration);
                    gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                    osc.connect(gain); gain.connect(this.ctx.destination);
                    osc.start(); osc.stop(this.ctx.currentTime + duration);
                } catch(e) {}
            }

            playNoise(duration, vol) {
                if (!this.ctx) return;
                try {
                    const bufferSize = this.ctx.sampleRate * duration;
                    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                    const noise = this.ctx.createBufferSource();
                    noise.buffer = buffer;
                    const gain = this.ctx.createGain();
                    gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                    noise.connect(gain); gain.connect(this.ctx.destination);
                    noise.start();
                } catch(e) {}
            }

            startAmbience() {
                if (!this.ctx) return;
                const bufferSize = this.ctx.sampleRate * 2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass'; filter.frequency.value = 200; 
                const gain = this.ctx.createGain();
                gain.gain.value = 0.03; 
                noise.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
                noise.start();
            }

            startBGM() {
                if (!this.ctx) return;
                if (this.bgmTimer) clearTimeout(this.bgmTimer);
                const bassLine = [110, 0, 110, 0, 146, 0, 130, 0, 110, 0, 0, 110, 98, 0, 130, 0]; 
                const kick = [1, 0, 0, 0,  1, 0, 0, 0,  1, 0, 0, 0,  1, 0, 0, 0];
                const hat  = [0, 0, 1, 0,  0, 0, 1, 0,  0, 0, 1, 0,  0, 0, 1, 1];
                const lead = [440, 0, 523, 0,  587, 0, 659, 0,  523, 0, 587, 0,  440, 0, 392, 0];
                const stepTime = 125; 

                const playStep = () => {
                    if (!this.isPlaying) return;
                    const i = this.bgmStep % 16;
                    if (kick[i]) this.playTone(100, 'sine', 0.1, 0.3, 0.01);
                    if (hat[i]) this.playNoise(0.05, 0.05);
                    if (bassLine[i]) this.playTone(bassLine[i], 'sawtooth', 0.1, 0.1);
                    if (lead[i] && Math.random() > 0.3) this.playTone(lead[i], 'square', 0.1, 0.05);
                    this.bgmStep++;
                    this.bgmTimer = setTimeout(playStep, stepTime);
                };
                playStep();
            }

            playShoot() { this.playTone(880, 'sine', 0.15, 0.1, 110); }
            playEnemyShoot() { this.playTone(300, 'sawtooth', 0.3, 0.1, 50); }
            playHit() { this.playNoise(0.1, 0.2); this.playTone(150, 'square', 0.1, 0.1, 50); }
            playDamage() { this.playTone(100, 'sawtooth', 0.4, 0.3, 20); this.playNoise(0.2, 0.2); }
            playPowerUp() { 
                this.playTone(523, 'sine', 0.1, 0.2);
                setTimeout(()=>this.playTone(659, 'sine', 0.1, 0.2), 50);
                setTimeout(()=>this.playTone(784, 'sine', 0.2, 0.2), 100);
            }
            playFootstep() {
                if (!this.ctx || this.ctx.currentTime < this.nextStepTime) return;
                this.playNoise(0.05, 0.05);
                this.nextStepTime = this.ctx.currentTime + 0.4;
            }
            playExplosion() {
                // ÁÇ∏ÂΩàÁàÜÁÇ∏Èü≥Êïà
                this.playNoise(0.5, 0.5); // ÁàÜÁÇ∏ËÅ≤
                this.playTone(80, 'sawtooth', 0.5, 0.5, 20); // ‰ΩéÈ†ªËΩüÈ≥¥
            }
            playWin() { 
                this.stop();
                [523, 659, 784, 1046].forEach((f,i)=>setTimeout(()=>this.playTone(f,'square',0.2,0.2),i*100)); 
            }
            playLose() { 
                this.stop();
                this.playTone(200,'sawtooth',0.5,0.3, 50); 
                setTimeout(()=>this.playTone(150,'sawtooth',1.0,0.3, 20), 400); 
            }
        }
        const soundManager = new SoundManager();

        window.handleAction = function() {
            const btn = document.getElementById('action-btn');
            const resultScreen = document.getElementById('result-screen');
            if (btn.classList.contains('btn-next')) {
                currentLevel++;
                if (currentLevel > 100) {
                    location.reload();
                } else {
                    resultScreen.style.display = 'none';
                    startLevel(currentLevel);
                }
            } else {
                resultScreen.style.display = 'none';
                startLevel(currentLevel);
            }
        };

        init();
        animate();

        function init() {
            const container = document.getElementById('game-container');
            const rect = container.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 250);

            camera = new THREE.PerspectiveCamera(75, 16 / 9, 1, 1000);
            camera.rotation.order = 'YXZ'; 

            const weaponGeo = new THREE.BoxGeometry(0.5, 0.5, 4);
            const weaponMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            weaponMesh = new THREE.Mesh(weaponGeo, weaponMat);
            weaponMesh.position.set(1.5, -1.5, -2);
            weaponMesh.rotation.x = -0.2;
            weaponMesh.rotation.y = -0.2;
            camera.add(weaponMesh);
            scene.add(camera);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
            sunLight.position.set(100, 200, 100);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048; sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.left = -300; sunLight.shadow.camera.right = 300;
            sunLight.shadow.camera.top = 300; sunLight.shadow.camera.bottom = -300;
            scene.add(sunLight);
            scene.add(worldGroup);

            const startBtn = document.getElementById('start-btn');
            startBtn.addEventListener('click', function(e) {
                e.preventDefault(); 
                document.getElementById('blocker').style.display = 'none';
                soundManager.init();
                startLevel(1);
            });

            // Ë¶ñËßíÈéñÂÆöÊåâÈàï
            const lockBtn = document.getElementById('btn-camera-lock');
            lockBtn.addEventListener('click', (e) => {
                e.preventDefault();
                cameraLocked = !cameraLocked;
                if(cameraLocked) {
                    lockBtn.innerText = 'üîí';
                    lockBtn.classList.add('locked');
                } else {
                    lockBtn.innerText = 'üîì';
                    lockBtn.classList.remove('locked');
                }
            });
            // ÊîØÊè¥Ëß∏Êéß
            lockBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                cameraLocked = !cameraLocked;
                if(cameraLocked) {
                    lockBtn.innerText = 'üîí';
                    lockBtn.classList.add('locked');
                } else {
                    lockBtn.innerText = 'üîì';
                    lockBtn.classList.remove('locked');
                }
            }, { passive: false });

            // Ëß∏ÊéßÁ∂ÅÂÆö
            const bindTouch = (id, startAction, endAction) => {
                const btn = document.getElementById(id);
                btn.addEventListener('touchstart', (e) => { e.preventDefault(); startAction(); btn.classList.add('pressed'); }, { passive: false });
                btn.addEventListener('touchend', (e) => { e.preventDefault(); endAction(); btn.classList.remove('pressed'); }, { passive: false });
                btn.addEventListener('mousedown', () => { startAction(); btn.classList.add('pressed'); });
                btn.addEventListener('mouseup', () => { endAction(); btn.classList.remove('pressed'); });
                btn.addEventListener('mouseleave', () => { endAction(); btn.classList.remove('pressed'); });
            };

            bindTouch('btn-up', () => moveForward = true, () => moveForward = false);
            bindTouch('btn-down', () => moveBackward = true, () => moveBackward = false);
            bindTouch('btn-left', () => rotateLeft = true, () => rotateLeft = false);
            bindTouch('btn-right', () => rotateRight = true, () => rotateRight = false);
            bindTouch('btn-skill', () => shoot(), () => {});

            // ÈçµÁõ§
            const onKeyDown = (e) => {
                const k = e.key.toLowerCase(), c = e.code;
                if(c==='ArrowUp'||c==='KeyW'||k==='w') { moveForward=true; document.getElementById('btn-up').classList.add('pressed'); }
                if(c==='ArrowDown'||c==='KeyS'||k==='s') { moveBackward=true; document.getElementById('btn-down').classList.add('pressed'); }
                if(c==='ArrowLeft'||c==='KeyA'||k==='a') { rotateLeft=true; document.getElementById('btn-left').classList.add('pressed'); }
                if(c==='ArrowRight'||c==='KeyD'||k==='d') { rotateRight=true; document.getElementById('btn-right').classList.add('pressed'); }
                if(c==='Space'||k===' ') { shoot(); document.getElementById('btn-skill').classList.add('pressed'); }
            };
            const onKeyUp = (e) => {
                const k = e.key.toLowerCase(), c = e.code;
                if(c==='ArrowUp'||c==='KeyW'||k==='w') { moveForward=false; document.getElementById('btn-up').classList.remove('pressed'); }
                if(c==='ArrowDown'||c==='KeyS'||k==='s') { moveBackward=false; document.getElementById('btn-down').classList.remove('pressed'); }
                if(c==='ArrowLeft'||c==='KeyA'||k==='a') { rotateLeft=false; document.getElementById('btn-left').classList.remove('pressed'); }
                if(c==='ArrowRight'||c==='KeyD'||k==='d') { rotateRight=false; document.getElementById('btn-right').classList.remove('pressed'); }
                if(c==='Space'||k===' ') { document.getElementById('btn-skill').classList.remove('pressed'); }
            };
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(width, height);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            window.addEventListener('resize', onWindowResize);
        }

        function getLevelData(level) {
            let size = 15 + Math.floor((level - 1) / 2) * 2;
            if (size > 61) size = 61;
            let enemies = Math.floor(5 + level * 1.5);
            let time = 300 + (level * 10);
            return { id: level, size: size, time: time, enemies: enemies };
        }

        function startLevel(level) {
            currentLevel = level;
            currentLevelData = getLevelData(level);

            while(worldGroup.children.length > 0) worldGroup.remove(worldGroup.children[0]);
            enemies = [];
            items = [];
            projectiles = [];
            grenades = []; // Ê∏ÖÁ©∫ÁÇ∏ÂΩà
            
            playerStats.hp = playerStats.maxHp;
            playerStats.speedMulti = 1.0;
            playerStats.invincible = 0;
            enemySpeedMulti = 1.0;
            updateHPBar();
            updateStatusEffects();

            document.getElementById('level-num').innerText = currentLevel;
            const warning = document.getElementById('enemy-warning');
            warning.style.display = 'block';
            warning.innerText = `‚ö†Ô∏è Level ${currentLevel}: Êïµ‰∫∫ÂÖ®Èù¢ÁãÇÊö¥ÔºÅ`;

            timeLeft = currentLevelData.time;
            updateTimeDisplay();

            createMazeWorld(currentLevelData.size);
            spawnMapEntities();
            spawnItems(5 + Math.floor(currentLevel/5)); 

            moveForward = false; moveBackward = false; rotateLeft = false; rotateRight = false;
            prevTime = performance.now();
            gameActive = true;
            
            soundManager.isPlaying = true;
            soundManager.startBGM();

            if(timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if(!gameActive) return;
                timeLeft--;
                updateTimeDisplay();
                if(timeLeft <= 0) gameOver(false, "ÊôÇÈñìËÄóÁõ°ÔºÅ");
            }, 1000);
        }

        function updateTimeDisplay() {
            const m = Math.floor(timeLeft/60).toString().padStart(2,'0');
            const s = (timeLeft%60).toString().padStart(2,'0');
            document.getElementById('time-display').innerText = `‚è∞ ${m}:${s}`;
        }

        function shoot() {
            if(!gameActive) return;
            soundManager.playShoot();
            weaponMesh.position.z = -1; 
            setTimeout(() => weaponMesh.position.z = -2, 100);

            const sphereGeo = new THREE.SphereGeometry(0.5, 8, 8);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(sphereGeo, sphereMat);
            
            const pos = new THREE.Vector3();
            const quat = new THREE.Quaternion();
            camera.getWorldPosition(pos);
            camera.getWorldQuaternion(quat);
            
            const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(quat).normalize();
            bullet.position.copy(pos).add(dir.clone().multiplyScalar(2));
            
            bullet.userData = { velocity: dir.multiplyScalar(60), life: 2.0, isEnemy: false, damage: 1 };
            worldGroup.add(bullet);
            projectiles.push(bullet);
        }

        function enemyShoot(enemy) {
            if(!gameActive) return;
            soundManager.playEnemyShoot();
            
            const size = enemy.isGuard ? 1.0 : 0.6;
            const color = enemy.isGuard ? 0x9b59b6 : 0xff0000;
            
            const sphereGeo = new THREE.SphereGeometry(size, 8, 8);
            const sphereMat = new THREE.MeshBasicMaterial({ color: color });
            const bullet = new THREE.Mesh(sphereGeo, sphereMat);
            
            const startPos = enemy.mesh.position.clone();
            const targetPos = camera.position.clone();
            targetPos.y -= 2;
            
            const dir = new THREE.Vector3().subVectors(targetPos, startPos).normalize();
            bullet.position.copy(startPos).add(dir.clone().multiplyScalar(5));
            
            const speed = enemy.isGuard ? 50 : 35; 
            const dmg = enemy.damage;

            bullet.userData = { velocity: dir.multiplyScalar(speed), life: 3.0, isEnemy: true, damage: dmg };
            worldGroup.add(bullet);
            projectiles.push(bullet);
        }

        // --- ÁÇ∏ÂΩàÂäüËÉΩ ---
        function enemyThrowGrenade(enemy) {
            if(!gameActive) return;
            
            // ÊããÁâ©Á∑öÁÇ∏ÂΩà
            const grenadeGeo = new THREE.SphereGeometry(1.5, 8, 8);
            const grenadeMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.5 });
            const grenade = new THREE.Mesh(grenadeGeo, grenadeMat);
            
            const startPos = enemy.mesh.position.clone();
            startPos.y += 5; // ÂæûÈ†≠È†Ç‰∏üÂá∫
            grenade.position.copy(startPos);
            
            const targetPos = camera.position.clone();
            // Ë®àÁÆóÊñπÂêë
            const dir = new THREE.Vector3().subVectors(targetPos, startPos);
            const dist = dir.length();
            dir.normalize();
            
            // Á∞°ÂñÆÁâ©ÁêÜÊ®°Êì¨ÔºöÊ∞¥Âπ≥ÈÄüÂ∫¶ + ÂûÇÁõ¥ÈÄüÂ∫¶
            const speed = dist * 1.5; // Ë∑ùÈõ¢Ë∂äÈÅ†‰∏üË∂äÂø´
            const velocity = dir.multiplyScalar(speed);
            velocity.y = 30; // ÂæÄ‰∏äÊãã
            
            grenade.userData = { 
                velocity: velocity, 
                life: 3.0, // 3ÁßíÂæåÁàÜÁÇ∏
                onGround: false 
            };
            
            worldGroup.add(grenade);
            grenades.push(grenade);
        }

        function updateGrenades(dt) {
            for (let i = grenades.length - 1; i >= 0; i--) {
                const g = grenades[i];
                
                // Ë®àÊôÇ
                g.userData.life -= dt;
                
                if (!g.userData.onGround) {
                    // ÈáçÂäõÁâ©ÁêÜ
                    g.userData.velocity.y -= 80 * dt; // ÈáçÂäõ
                    g.position.add(g.userData.velocity.clone().multiplyScalar(dt));
                    
                    // ËêΩÂú∞Ê™¢Ê∏¨
                    if (g.position.y <= 1.5) {
                        g.position.y = 1.5;
                        g.userData.onGround = true;
                        // ËêΩÂú∞ÂæåÁ®çÂæÆÊªæÂãï‰∏ÄÈªûÂ∞±ÂÅú
                        g.userData.velocity.set(0,0,0);
                    }
                } else {
                    // ËêΩÂú∞ÂæåÈñÉÁàç
                    const blink = Math.sin(Date.now() * 0.02) > 0;
                    g.material.emissive.setHex(blink ? 0xff0000 : 0x000000);
                }

                // ÁàÜÁÇ∏
                if (g.userData.life <= 0) {
                    explodeGrenade(g);
                    worldGroup.remove(g);
                    grenades.splice(i, 1);
                }
            }
        }

        function explodeGrenade(g) {
            soundManager.playExplosion();
            
            // Ë¶ñË¶∫ÊïàÊûú (Á¥ÖËâ≤ÁàÜÁÇ∏ÁêÉ)
            const boomGeo = new THREE.SphereGeometry(15, 16, 16);
            const boomMat = new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.8 });
            const boom = new THREE.Mesh(boomGeo, boomMat);
            boom.position.copy(g.position);
            worldGroup.add(boom);
            
            // ÂÇ∑ÂÆ≥Âà§ÂÆö
            const dist = g.position.distanceTo(camera.position);
            if (dist < 15) {
                takeDamage(30); // ÁÇ∏ÂΩàÂæàÁóõ
            }
            
            // ÁßªÈô§ÁàÜÁÇ∏ÊïàÊûú
            setTimeout(() => { worldGroup.remove(boom); }, 300);
        }

        function spawnMapEntities() {
            const roamingCount = currentLevelData.enemies;
            for(let i=0; i<roamingCount; i++) spawnEnemy('roaming');
            const guardCount = 2 + Math.floor((currentLevel - 1) / 3);
            spawnGuardsAroundExit(guardCount);
        }

        function spawnEnemy(type, specificX, specificZ) {
            const isGuard = type === 'guard';
            const size = isGuard ? 9 : 7;
            const color = isGuard ? 0x5d4037 : 0x000000;
            
            const geo = new THREE.BoxGeometry(size, size, size);
            const mat = new THREE.MeshStandardMaterial({ color: color });
            const eyeGeo = new THREE.BoxGeometry(size/7, size/7, size/10);
            const eyeMat = new THREE.MeshBasicMaterial({ color: isGuard ? 0xffff00 : 0xff0000 });

            let px, pz;
            if (specificX !== undefined && specificZ !== undefined) {
                px = (specificX - currentLevelData.size/2) * TILE_SIZE;
                pz = (specificZ - currentLevelData.size/2) * TILE_SIZE;
            } else {
                let x, z, attempts = 0;
                do {
                    x = Math.floor(Math.random() * currentLevelData.size);
                    z = Math.floor(Math.random() * currentLevelData.size);
                    attempts++;
                } while (maze[z][x] === 1 && attempts < 100);
                if (maze[z][x] === 1) return;
                px = (x - currentLevelData.size/2) * TILE_SIZE;
                pz = (z - currentLevelData.size/2) * TILE_SIZE;
            }

            const group = new THREE.Group();
            const body = new THREE.Mesh(geo, mat);
            const eyeL = new THREE.Mesh(eyeGeo, eyeMat); 
            eyeL.position.set(-size*0.25, size*0.15, size*0.5+0.1);
            const eyeR = new THREE.Mesh(eyeGeo, eyeMat); 
            eyeR.position.set(size*0.25, size*0.15, size*0.5+0.1);
            group.add(body, eyeL, eyeR);
            
            group.position.set(px, size/2, pz);
            group.castShadow = true;

            worldGroup.add(group);
            
            const baseHp = isGuard ? 7 : 3;
            const hpGrowth = isGuard ? 2 : 0.5;
            const maxHp = Math.floor(baseHp + currentLevel * hpGrowth);
            const damage = Math.floor((isGuard ? 15 : 8) + currentLevel * 1.0);

            enemies.push({ 
                mesh: group, 
                hp: maxHp, 
                maxHp: maxHp,
                speed: isGuard ? 10 : (15 + Math.random() * 10),
                lastShot: 0,
                lastGrenade: 0, // Êñ∞Â¢ûÁÇ∏ÂΩàÂÜ∑Âçª
                isGuard: isGuard,
                damage: damage,
                aggroRange: isGuard ? 80 : 120, 
                shootRange: isGuard ? 70 : 90
            });
        }

        function spawnGuardsAroundExit(count) {
            const ex = currentLevelData.size - 2; 
            const ey = currentLevelData.size - 2;
            let spots = [];
            for(let y = ey-4; y <= ey+4; y++) {
                for(let x = ex-4; x <= ex+4; x++) {
                    if (x>0 && x<currentLevelData.size-1 && y>0 && y<currentLevelData.size-1) {
                        if (maze[y][x] === 0) spots.push({x, y});
                    }
                }
            }
            for(let i=0; i<count; i++) {
                if (spots.length === 0) break;
                const idx = Math.floor(Math.random() * spots.length);
                const spot = spots[idx];
                spawnEnemy('guard', spot.x, spot.y);
            }
        }

        function spawnItems(count) {
            const geo = new THREE.BoxGeometry(2, 2, 2);
            const colors = [0xffff00, 0x00ffff, 0xff0000];
            const types = ['speed', 'slow', 'heal'];

            for(let i=0; i<count; i++) {
                let x, z;
                let attempts = 0;
                do {
                    x = Math.floor(Math.random() * currentLevelData.size);
                    z = Math.floor(Math.random() * currentLevelData.size);
                    attempts++;
                } while (maze[z][x] === 1 && attempts < 100);

                if (maze[z][x] === 0) {
                    const typeIdx = Math.floor(Math.random() * 3);
                    const mat = new THREE.MeshStandardMaterial({ 
                        color: colors[typeIdx], emissive: colors[typeIdx], emissiveIntensity: 0.5 
                    });
                    const item = new THREE.Mesh(geo, mat);
                    const px = (x - currentLevelData.size/2) * TILE_SIZE;
                    const pz = (z - currentLevelData.size/2) * TILE_SIZE;
                    item.position.set(px, 4, pz);
                    worldGroup.add(item);
                    items.push({ mesh: item, type: types[typeIdx] });
                }
            }
        }

        function updateProjectiles(dt) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const b = projectiles[i];
                const move = b.userData.velocity.clone().multiplyScalar(dt);
                b.position.add(move);
                b.userData.life -= dt;

                let hit = false;
                if (checkCollision(b.position)) hit = true;

                if (!hit) {
                    if (b.userData.isEnemy) {
                        const playerPos = camera.position;
                        if (b.position.distanceTo(playerPos) < 4) {
                            takeDamage(b.userData.damage);
                            hit = true;
                        }
                    } else {
                        for (let j = enemies.length - 1; j >= 0; j--) {
                            const enemy = enemies[j];
                            const hitRadius = enemy.isGuard ? 9 : 7;
                            if (b.position.distanceTo(enemy.mesh.position) < hitRadius) {
                                soundManager.playHit();
                                enemy.hp--;
                                const pushDir = b.userData.velocity.clone().normalize().multiplyScalar(enemy.isGuard ? 2 : 5);
                                enemy.mesh.position.add(pushDir);
                                
                                if (enemy.hp <= 0) {
                                    worldGroup.remove(enemy.mesh);
                                    enemies.splice(j, 1);
                                    if(!enemy.isGuard) {
                                        setTimeout(() => { if(gameActive) spawnEnemy('roaming'); }, 3000);
                                    }
                                } else {
                                    enemy.mesh.children[0].material.emissive.setHex(0xff0000);
                                    setTimeout(()=>enemy.mesh.children[0].material.emissive.setHex(0x000000), 100);
                                }
                                hit = true;
                                break;
                            }
                        }
                    }
                }

                if (hit || b.userData.life <= 0) {
                    worldGroup.remove(b);
                    projectiles.splice(i, 1);
                }
            }
        }

        function updateEnemies(dt, now) {
            const playerPos = camera.position;
            enemies.forEach(e => {
                const dist = e.mesh.position.distanceTo(playerPos);
                
                if (dist < e.aggroRange) { 
                    e.mesh.lookAt(playerPos.x, e.mesh.position.y, playerPos.z);
                    const dir = new THREE.Vector3().subVectors(playerPos, e.mesh.position).normalize();
                    dir.y = 0;
                    
                    const moveDist = e.speed * enemySpeedMulti * dt;
                    const nextPos = e.mesh.position.clone().add(dir.multiplyScalar(moveDist));
                    
                    if (!checkCollision(nextPos)) e.mesh.position.copy(nextPos);
                    
                    if (dist < (e.isGuard ? 10 : 7)) {
                        takeDamage(10);
                        e.mesh.position.sub(dir.multiplyScalar(10)); 
                    }

                    // Â∞ÑÊìäÂà§ÂÆö
                    const shootCooldown = e.isGuard ? 800 : 1500;
                    if (dist < e.shootRange && now - e.lastShot > shootCooldown) { 
                        enemyShoot(e);
                        e.lastShot = now;
                    }

                    // ‰∏üÁÇ∏ÂΩàÂà§ÂÆö (Èö®Ê©ü)
                    const grenadeCooldown = 5000; // 5Áßí
                    if (dist < 100 && dist > 30 && now - e.lastGrenade > grenadeCooldown) {
                        if (Math.random() > 0.7) { // 30% Ê©üÁéá
                            enemyThrowGrenade(e);
                            e.lastGrenade = now;
                        }
                    }
                }
                e.mesh.scale.setScalar(1 + Math.sin(now * 0.005) * 0.05);
            });
        }

        function updateItems(dt) {
            const playerPos = camera.position;
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                item.mesh.rotation.y += dt;
                item.mesh.position.y = 4 + Math.sin(Date.now() * 0.005);

                const dx = item.mesh.position.x - playerPos.x;
                const dz = item.mesh.position.z - playerPos.z;
                const dist2d = Math.sqrt(dx*dx + dz*dz);

                if (dist2d < 6) { 
                    applyEffect(item.type);
                    worldGroup.remove(item.mesh);
                    items.splice(i, 1);
                }
            }
        }

        function takeDamage(amount) {
            if (playerStats.invincible > 0) return;
            playerStats.hp -= amount;
            soundManager.playDamage();
            updateHPBar();
            scene.background = new THREE.Color(0x550000);
            setTimeout(() => scene.background = new THREE.Color(0x87CEEB), 100);
            playerStats.invincible = 1.0; 
            if (playerStats.hp <= 0) gameOver(false, "‰Ω†Ë¢´ÊìäÊïó‰∫ÜÔºÅ");
        }

        function applyEffect(type) {
            soundManager.playPowerUp();
            if (type === 'heal') {
                playerStats.hp = Math.min(playerStats.hp + 30, playerStats.maxHp);
                updateHPBar();
            } else if (type === 'speed') {
                playerStats.speedMulti = 1.8;
                setTimeout(() => { playerStats.speedMulti = 1.0; updateStatusEffects(); }, 8000);
            } else if (type === 'slow') {
                enemySpeedMulti = 0.3;
                setTimeout(() => { enemySpeedMulti = 1.0; updateStatusEffects(); }, 8000);
            }
            updateStatusEffects();
        }

        function updateStatusEffects() {
            const div = document.getElementById('status-effects');
            div.innerHTML = '';
            if (playerStats.speedMulti > 1) div.innerHTML += '<div class="effect-badge" style="background:#f1c40f; color:#000;">‚ö°Âä†ÈÄü‰∏≠</div>';
            if (enemySpeedMulti < 1) div.innerHTML += '<div class="effect-badge" style="background:#3498db; color:#fff;">‚ùÑÔ∏èÂáçÁµê‰∏≠</div>';
        }

        function updateHPBar() {
            const bar = document.getElementById('health-bar');
            const txt = document.getElementById('health-text');
            const pct = Math.max(0, (playerStats.hp / playerStats.maxHp) * 100);
            bar.style.width = pct + '%';
            txt.innerText = `HP: ${playerStats.hp}/${playerStats.maxHp}`;
        }

        function createBrickTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#a0a0a0'; ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#c0392b';
            for(let y=0; y<128; y+=18) {
                const off = (y/18)%2===0?0:16;
                for(let x=-16; x<128; x+=34) ctx.fillRect(x+off, y, 32, 16);
            }
            ctx.fillStyle = '#87CEEB'; ctx.fillRect(32,32,64,64);
            ctx.strokeStyle='#fff'; ctx.lineWidth=4; ctx.strokeRect(32,32,64,64);
            return new THREE.CanvasTexture(canvas);
        }

        function createPaverTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d'); ctx.fillStyle = '#7f8c8d'; ctx.fillRect(0,0,64,64);
            ctx.strokeStyle = '#636e72'; ctx.strokeRect(0,0,64,64);
            return new THREE.CanvasTexture(canvas);
        }

        function createMazeWorld(mazeSize) {
            maze = Array(mazeSize).fill().map(() => Array(mazeSize).fill(1));
            function carve(x, y) {
                const dirs = [[1,0], [-1,0], [0,1], [0,-1]].sort(() => Math.random()-0.5);
                dirs.forEach(([dx, dy]) => {
                    const nx = x + dx*2, ny = y + dy*2;
                    if (nx > 0 && nx < mazeSize-1 && ny > 0 && ny < mazeSize-1 && maze[ny][nx] === 1) {
                        maze[y+dy][x+dx] = 0; maze[ny][nx] = 0; carve(nx, ny);
                    }
                });
            }
            maze[1][1] = 0; carve(1,1);

            const floorSize = mazeSize * TILE_SIZE * 1.5;
            const floorMat = new THREE.MeshStandardMaterial({ map: createPaverTexture(), roughness: 0.8 });
            floorMat.map.repeat.set(floorSize/20, floorSize/20); floorMat.map.wrapS = floorMat.map.wrapT = THREE.RepeatWrapping;
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(floorSize, floorSize), floorMat);
            floor.rotation.x = -Math.PI/2; floor.receiveShadow = true;
            worldGroup.add(floor);

            const boxGeo = new THREE.BoxGeometry(TILE_SIZE, WALL_HEIGHT, TILE_SIZE);
            const wallMat = new THREE.MeshStandardMaterial({ map: createBrickTexture() });

            for(let y=0; y<mazeSize; y++){
                for(let x=0; x<mazeSize; x++){
                    const px = (x - mazeSize/2) * TILE_SIZE;
                    const pz = (y - mazeSize/2) * TILE_SIZE;
                    if(maze[y][x] === 1) {
                        const wall = new THREE.Mesh(boxGeo, wallMat);
                        wall.position.set(px, WALL_HEIGHT/2, pz);
                        wall.castShadow = true; wall.receiveShadow = true;
                        worldGroup.add(wall);
                    }
                }
            }

            maze[1][1] = 0; 
            camera.position.set((1 - mazeSize / 2) * TILE_SIZE, 8, (1 - mazeSize / 2) * TILE_SIZE);
            camera.rotation.y = Math.PI;

            let ex = mazeSize-2, ey = mazeSize-2;
            if(maze[ey][ex]===1) { ex=1; ey=mazeSize-2; }
            exitPosition.set((ex-mazeSize/2)*TILE_SIZE, 0, (ey-mazeSize/2)*TILE_SIZE);

            const exitGeo = new THREE.BoxGeometry(4, 100, 4);
            const exitMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.6 });
            const exitMark = new THREE.Mesh(exitGeo, exitMat);
            exitMark.position.copy(exitPosition); exitMark.position.y=50;
            worldGroup.add(exitMark);
        }

        function checkWinCondition() {
            const pos = camera.position;
            const dist = Math.hypot(pos.x - exitPosition.x, pos.z - exitPosition.z);
            if(dist < 10) gameOver(true, "ÈÅéÈóúÔºÅ");
        }

        function gameOver(win, message) {
            gameActive = false;
            clearInterval(timerInterval);
            const screen = document.getElementById('result-screen');
            const title = document.getElementById('result-title');
            const msg = document.getElementById('result-message');
            const btn = document.getElementById('action-btn');
            
            screen.style.display = 'flex';
            msg.innerText = message;

            if (win) {
                soundManager.playWin();
                if (currentLevel >= 100) {
                    title.innerText = "üèÜ ÂÇ≥Â•áË™ïÁîüÔºÅ";
                    title.className = "win-text";
                    msg.innerText = "‰Ω†ÂæÅÊúç‰∫Ü 100 Â±§Ëø∑ÂÆÆÔºÅ";
                    btn.innerText = "ÈáçÊñ∞ÈñãÂßã";
                    btn.className = "action-btn btn-next";
                } else {
                    title.innerText = "üéâ ÈÄÉËÑ´ÊàêÂäüÔºÅ";
                    title.className = "win-text";
                    btn.innerText = "‰∏ã‰∏ÄÈóú >>";
                    btn.className = "action-btn btn-next";
                }
            } else {
                soundManager.playLose();
                title.innerText = "üíÄ ‰ªªÂãôÂ§±Êïó";
                title.className = "lose-text";
                btn.innerText = "ÈáçË©¶Êú¨Èóú";
                btn.className = "action-btn btn-retry";
            }
        }

        function checkCollision(pos) {
            const pX = pos.x; const pZ = pos.z; const r = 1.5; 
            const checks = [{x:pX+r, z:pZ}, {x:pX-r, z:pZ}, {x:pX, z:pZ+r}, {x:pX, z:pZ-r}];
            const ms = currentLevelData.size;
            for (let p of checks) {
                const gx = Math.round((p.x / TILE_SIZE) + (ms / 2));
                const gy = Math.round((p.z / TILE_SIZE) + (ms / 2));
                if (gx >= 0 && gx < ms && gy >= 0 && gy < ms) {
                    if (maze[gy][gx] === 1) return true;
                }
            }
            return false;
        }

        function onWindowResize() {
            const container = document.getElementById('game-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1); 
            prevTime = time;

            if (gameActive) {
                if (playerStats.invincible > 0) playerStats.invincible -= delta;

                updateProjectiles(delta);
                updateEnemies(delta, time);
                updateGrenades(delta); // Êñ∞Â¢ûÁÇ∏ÂΩàÊõ¥Êñ∞
                updateItems(delta);

                // --- Ë¶ñËßíËàáÁßªÂãïÈÇèËºØÊõ¥Êñ∞ ---
                // 1. ÊóãËΩâ/Âπ≥ÁßªËôïÁêÜ
                if (cameraLocked) {
                    // ÈéñÂÆöÊ®°ÂºèÔºöÂ∑¶Âè≥ÈçµÊòØÂπ≥Áßª (Strafe)
                    // Âú®ÁßªÂãïË®àÁÆó‰∏≠ËôïÁêÜ
                } else {
                    // Ëß£ÈéñÊ®°ÂºèÔºöÂ∑¶Âè≥ÈçµÊòØÊóãËΩâ (Rotate)
                    if (rotateLeft) camera.rotation.y += ROTATE_SPEED * delta;
                    if (rotateRight) camera.rotation.y -= ROTATE_SPEED * delta;
                }

                // 2. ÁßªÂãïË®àÁÆó
                let moveSpeed = 0;
                let strafeSpeed = 0;
                const finalSpeed = PLAYER_BASE_SPEED * playerStats.speedMulti;
                
                if (moveForward) moveSpeed = finalSpeed * delta;
                if (moveBackward) moveSpeed = -finalSpeed * delta;

                if (cameraLocked) {
                    if (rotateLeft) strafeSpeed = -finalSpeed * delta;
                    if (rotateRight) strafeSpeed = finalSpeed * delta;
                }

                if (moveSpeed !== 0 || strafeSpeed !== 0) {
                    // Ë®àÁÆóÂâçÈÄ≤ÊñπÂêë
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    forward.y = 0; forward.normalize();
                    
                    // Ë®àÁÆóÂè≥ÊñπÊñπÂêë (Áî®Êñº Strafe)
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    right.y = 0; right.normalize();

                    const currentPos = camera.position.clone();
                    
                    // ÁµÑÂêàÁßªÂãïÂêëÈáè
                    const moveVec = forward.multiplyScalar(moveSpeed).add(right.multiplyScalar(strafeSpeed));
                    
                    const nextX = currentPos.x + moveVec.x;
                    const nextZ = currentPos.z + moveVec.z;

                    if (!checkCollision(new THREE.Vector3(nextX, currentPos.y, currentPos.z))) camera.position.x = nextX;
                    if (!checkCollision(new THREE.Vector3(camera.position.x, currentPos.y, nextZ))) camera.position.z = nextZ;
                    
                    soundManager.playFootstep();
                }
                checkWinCondition();
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
