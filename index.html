<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ ¡åœ’è¿·å®®é€ƒè„« (100é—œç„¡ç›¡ç‰ˆ)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #87CEEB;
            user-select: none;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        #hud {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            color: #fff;
            text-shadow: 3px 3px 0px #000;
            font-family: 'Arial Black', sans-serif;
            background: linear-gradient(to bottom, rgba(0,0,0,0.4), transparent);
        }
        
        #health-container {
            width: 300px;
            height: 30px;
            background: #333;
            border: 4px solid #fff;
            border-radius: 15px;
            overflow: hidden;
            margin-top: 10px;
            position: relative;
        }
        #health-bar {
            width: 100%;
            height: 100%;
            background: #e74c3c;
            transition: width 0.2s;
        }
        #health-text {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            font-size: 18px; text-shadow: 1px 1px 0 #000;
        }

        #status-effects {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }
        .effect-badge {
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
            animation: pulse 1s infinite;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        #input-debug {
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            pointer-events: none;
            opacity: 0.9;
        }
        .key-row { display: flex; gap: 8px; }
        .key-icon {
            width: 45px; height: 45px;
            background: #fff; border-bottom: 4px solid #ccc; color: #333;
            display: flex; align-items: center; justify-content: center;
            font-weight: 900; border-radius: 8px; font-family: 'Arial Black', sans-serif;
            font-size: 20px; transition: all 0.1s;
        }
        .key-active { background: #f39c12; border-bottom: 0px solid #d35400; transform: translateY(4px); color: white; }
        .key-space { width: 150px; } 

        #blocker {
            position: absolute; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7); backdrop-filter: blur(5px);
            display: flex; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 10;
        }
        #instructions {
            width: 600px; padding: 40px;
            background: linear-gradient(135deg, #ffffff, #f0f0f0);
            border-radius: 20px; text-align: center; color: #333;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5); border: 5px solid #fff;
        }
        h1 { margin: 0 0 10px 0; color: #c0392b; font-size: 42px; font-family: 'Arial Black', sans-serif; letter-spacing: -1px; }
        p { font-size: 18px; margin: 8px 0; color: #555; font-weight: bold; }
        .key { background: #fff; color: #333; padding: 4px 10px; border: 2px solid #ccc; border-radius: 6px; font-weight: 900; font-family: monospace; display: inline-block; box-shadow: 0 2px 0 #bbb; }
        
        #start-btn {
            background: #2ecc71; color: white; font-size: 28px; padding: 15px 60px;
            border: none; border-radius: 15px; cursor: pointer; margin-top: 25px;
            box-shadow: 0 6px 0 #27ae60; transition: transform 0.1s;
            font-weight: 900; font-family: 'Arial Black', sans-serif; text-transform: uppercase;
        }
        #start-btn:active { transform: translateY(6px); box-shadow: 0 0 0 #27ae60; }
        #start-btn:hover { background: #27ae60; }

        #result-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 10, 10, 0.95); color: white; z-index: 20;
            flex-direction: column; align-items: center; justify-content: center;
            text-align: center; pointer-events: auto;
        }
        button.action-btn {
            padding: 20px 50px; font-size: 24px; color: white; border: none; border-radius: 15px;
            cursor: pointer; margin-top: 30px; box-shadow: 0 6px 0 rgba(0,0,0,0.2);
            transition: transform 0.1s; font-weight: bold; font-family: 'Arial Black', sans-serif;
        }
        .btn-next { background: #3498db; box-shadow: 0 6px 0 #2980b9; }
        .btn-retry { background: #e74c3c; box-shadow: 0 6px 0 #c0392b; }
        .btn-next:active, .btn-retry:active { transform: translateY(6px); box-shadow: none; }
        
        .win-text { color: #2ecc71; font-size: 60px; text-shadow: 4px 4px 0 #27ae60; font-family: 'Arial Black', sans-serif; }
        .lose-text { color: #e74c3c; font-size: 60px; text-shadow: 4px 4px 0 #c0392b; font-family: 'Arial Black', sans-serif; }
        .warning-text { color: #f39c12; font-size: 24px; margin-top: 10px; display: none; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="hud">
            <div>
                <div style="font-size: 32px; color: #f1c40f;">Level <span id="level-num">1</span> / 100</div>
                <div id="time-display">â° 05:00</div>
                <div id="status-effects"></div>
                <div id="enemy-warning" class="warning-text">âš ï¸ æ•µäººé–‹å§‹ä¸»å‹•æ”»æ“Šï¼</div>
            </div>
            <div style="text-align: right;">
                <div id="status">å°‹æ‰¾ç¶ è‰²å…‰æŸ±</div>
                <div id="health-container">
                    <div id="health-bar"></div>
                    <div id="health-text">HP: 100/100</div>
                </div>
            </div>
        </div>
        <div id="input-debug">
            <div class="key-row">
                <div id="key-w" class="key-icon">W</div>
            </div>
            <div class="key-row">
                <div id="key-a" class="key-icon">A</div>
                <div id="key-s" class="key-icon">S</div>
                <div id="key-d" class="key-icon">D</div>
            </div>
            <div class="key-row">
                <div id="key-space" class="key-icon key-space">SPACE (æ”»æ“Š)</div>
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="blocker">
        <div id="instructions">
            <h1 id="menu-title">æ ¡åœ’ç”Ÿå­˜é€ƒè„«</h1>
            <p id="menu-subtitle">100 å±¤ç„¡ç›¡æŒ‘æˆ°ï¼æ´»ä¸‹å»ï¼</p>
            <hr style="border: 2px dashed #ddd; margin: 20px 0;">
            <p><span class="key">W</span> <span class="key">S</span> ç§»å‹• &nbsp; <span class="key">A</span> <span class="key">D</span> è½‰å‘</p>
            <p><span class="key" style="width: 100px;">SPACE</span> ç™¼å°„é­”æ³•å½ˆ</p>
            <p>âš¡åŠ é€Ÿ &nbsp; â„ï¸ç·©é€Ÿæ•µäºº &nbsp; â¤ï¸è£œè¡€</p>
            <p style="color: #e67e22; font-size: 16px;">(ç¬¬ 3 é—œå¾Œæ•µäººæœƒç™¼å‹•æ”»æ“Šèˆ‡é‡ç”Ÿ)</p>
            <br>
            <button id="start-btn">é–‹å§‹æŒ‘æˆ°</button>
            <p style="font-size: 14px; margin-top: 15px; color: #e74c3c;">âš ï¸ è«‹ç¢ºèªè¼¸å…¥æ³•ç‚ºè‹±æ–‡</p>
        </div>
    </div>

    <div id="result-screen">
        <div id="result-title" class="win-text"></div>
        <p id="result-message" style="font-size: 24px; margin: 20px; color: #ddd; font-weight: bold;"></p>
        <button id="action-btn" class="action-btn" onclick="handleAction()">ä¸‹ä¸€é—œ</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- å…¨åŸŸè®Šæ•¸ ---
        let camera, scene, renderer;
        let worldGroup = new THREE.Group();
        
        let playerStats = { hp: 100, maxHp: 100, speedMulti: 1.0, invincible: 0 };
        const PLAYER_BASE_SPEED = 250.0;
        const ROTATE_SPEED = 2.0;
        let weaponMesh;
        let projectiles = [];
        
        let moveForward = false, moveBackward = false, rotateLeft = false, rotateRight = false;
        
        let enemies = [];
        let items = [];
        let maze = [];
        let exitPosition = new THREE.Vector3();
        
        let prevTime = performance.now();
        const TILE_SIZE = 25;
        const WALL_HEIGHT = 20;
        let gameActive = false;
        let timeLeft = 0;
        let timerInterval;
        let enemySpeedMulti = 1.0;

        let currentLevel = 1; // 1 ~ 100
        let currentLevelData = {};

        // --- éŸ³æ•ˆç®¡ç†å™¨ ---
        class SoundManager {
            constructor() { this.ctx = null; }
            init() {
                if(!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                }
                if(this.ctx.state === 'suspended') this.ctx.resume();
            }
            playTone(freq, type, duration, vol = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + duration);
            }
            playNoise(duration, vol) {
                if (!this.ctx) return;
                const bufferSize = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                noise.connect(gain); gain.connect(this.ctx.destination);
                noise.start();
            }
            playShoot() { this.playTone(600, 'square', 0.1, 0.1); setTimeout(()=>this.playTone(300, 'square', 0.1, 0.1), 50); }
            playEnemyShoot() { this.playTone(200, 'sawtooth', 0.1, 0.1); }
            playHit() { this.playNoise(0.1, 0.2); }
            playPowerUp() { this.playTone(1000, 'sine', 0.2, 0.2); setTimeout(()=>this.playTone(1500, 'sine', 0.3, 0.2), 100); }
            playDamage() { this.playTone(100, 'sawtooth', 0.3, 0.3); }
            playWin() { [523, 659, 784, 1046].forEach((f,i)=>setTimeout(()=>this.playTone(f,'square',0.2,0.2),i*100)); }
            playLose() { this.playTone(200,'sawtooth',0.5,0.3); setTimeout(()=>this.playTone(100,'sawtooth',1.0,0.3),400); }
        }
        const soundManager = new SoundManager();

        window.handleAction = function() {
            const btn = document.getElementById('action-btn');
            const resultScreen = document.getElementById('result-screen');
            if (btn.classList.contains('btn-next')) {
                currentLevel++;
                if (currentLevel > 100) {
                    location.reload(); // å…¨ç ´
                } else {
                    resultScreen.style.display = 'none';
                    startLevel(currentLevel);
                }
            } else {
                resultScreen.style.display = 'none';
                startLevel(currentLevel);
            }
        };

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 250);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
            camera.rotation.order = 'YXZ'; 

            const weaponGeo = new THREE.BoxGeometry(0.5, 0.5, 4);
            const weaponMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            weaponMesh = new THREE.Mesh(weaponGeo, weaponMat);
            weaponMesh.position.set(1.5, -1.5, -2);
            weaponMesh.rotation.x = -0.2;
            weaponMesh.rotation.y = -0.2;
            camera.add(weaponMesh);
            scene.add(camera);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
            sunLight.position.set(100, 200, 100);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048; sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.left = -300; sunLight.shadow.camera.right = 300;
            sunLight.shadow.camera.top = 300; sunLight.shadow.camera.bottom = -300;
            scene.add(sunLight);
            scene.add(worldGroup);

            document.getElementById('start-btn').addEventListener('click', () => {
                document.getElementById('blocker').style.display = 'none';
                soundManager.init();
                startLevel(1);
            });

            const onKeyDown = (e) => {
                const k = e.key.toLowerCase(), c = e.code;
                if(c==='ArrowUp'||c==='KeyW'||k==='w') { moveForward=true; document.getElementById('key-w').classList.add('key-active'); }
                if(c==='ArrowDown'||c==='KeyS'||k==='s') { moveBackward=true; document.getElementById('key-s').classList.add('key-active'); }
                if(c==='ArrowLeft'||c==='KeyA'||k==='a') { rotateLeft=true; document.getElementById('key-a').classList.add('key-active'); }
                if(c==='ArrowRight'||c==='KeyD'||k==='d') { rotateRight=true; document.getElementById('key-d').classList.add('key-active'); }
                if(c==='Space'||k===' ') { shoot(); document.getElementById('key-space').classList.add('key-active'); }
            };
            const onKeyUp = (e) => {
                const k = e.key.toLowerCase(), c = e.code;
                if(c==='ArrowUp'||c==='KeyW'||k==='w') { moveForward=false; document.getElementById('key-w').classList.remove('key-active'); }
                if(c==='ArrowDown'||c==='KeyS'||k==='s') { moveBackward=false; document.getElementById('key-s').classList.remove('key-active'); }
                if(c==='ArrowLeft'||c==='KeyA'||k==='a') { rotateLeft=false; document.getElementById('key-a').classList.remove('key-active'); }
                if(c==='ArrowRight'||c==='KeyD'||k==='d') { rotateRight=false; document.getElementById('key-d').classList.remove('key-active'); }
                if(c==='Space'||k===' ') { document.getElementById('key-space').classList.remove('key-active'); }
            };
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', onWindowResize);
        }

        // --- å‹•æ…‹é—œå¡è¨ˆç®— ---
        function getLevelData(level) {
            // åœ°åœ–å¤§å°ï¼šå¾ 15 é–‹å§‹ï¼Œæ¯ 2 é—œ +2ï¼Œä¸Šé™ 61 (å¤ªå¤§æœƒè·‘ä¸å‹•)
            let size = 15 + Math.floor((level - 1) / 2) * 2;
            if (size > 61) size = 61;

            // æ•µäººæ•¸é‡ï¼šç·šæ€§æˆé•·ï¼Œæ¯é—œ +0.5 éš»çš„æ„Ÿè¦º
            let enemies = Math.floor(3 + level * 0.8);

            // æ™‚é–“ï¼šéš¨åœ°åœ–è®Šå¤§å¢åŠ 
            let time = 300 + (level * 10);

            return { id: level, size: size, time: time, enemies: enemies };
        }

        function startLevel(level) {
            currentLevel = level;
            currentLevelData = getLevelData(level);

            while(worldGroup.children.length > 0) worldGroup.remove(worldGroup.children[0]);
            enemies = [];
            items = [];
            projectiles = [];
            
            playerStats.hp = playerStats.maxHp;
            playerStats.speedMulti = 1.0;
            playerStats.invincible = 0;
            enemySpeedMulti = 1.0;
            updateHPBar();
            updateStatusEffects();

            document.getElementById('level-num').innerText = currentLevel;
            // è­¦å‘Šé¡¯ç¤º
            const warning = document.getElementById('enemy-warning');
            if(currentLevel >= 3) {
                warning.style.display = 'block';
                warning.innerText = `âš ï¸ Level ${currentLevel}: æ•µäººå°‡æœƒæ”»æ“Šä¸¦é‡ç”Ÿï¼`;
            } else {
                warning.style.display = 'none';
            }

            timeLeft = currentLevelData.time;
            updateTimeDisplay();

            createMazeWorld(currentLevelData.size);
            
            // åˆå§‹ç”Ÿæˆæ•µäºº
            for(let i=0; i<currentLevelData.enemies; i++) {
                spawnSingleEnemy();
            }
            spawnItems(5 + Math.floor(currentLevel/5)); 

            moveForward = false; moveBackward = false; rotateLeft = false; rotateRight = false;
            prevTime = performance.now();
            gameActive = true;

            if(timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if(!gameActive) return;
                timeLeft--;
                updateTimeDisplay();
                if(timeLeft <= 0) gameOver(false, "æ™‚é–“è€—ç›¡ï¼");
            }, 1000);
        }

        function updateTimeDisplay() {
            const m = Math.floor(timeLeft/60).toString().padStart(2,'0');
            const s = (timeLeft%60).toString().padStart(2,'0');
            document.getElementById('time-display').innerText = `â° ${m}:${s}`;
        }

        function shoot() {
            if(!gameActive) return;
            soundManager.playShoot();
            weaponMesh.position.z = -1; 
            setTimeout(() => weaponMesh.position.z = -2, 100);

            const sphereGeo = new THREE.SphereGeometry(0.5, 8, 8);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(sphereGeo, sphereMat);
            
            const pos = new THREE.Vector3();
            const quat = new THREE.Quaternion();
            camera.getWorldPosition(pos);
            camera.getWorldQuaternion(quat);
            
            const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(quat).normalize();
            bullet.position.copy(pos).add(dir.clone().multiplyScalar(2));
            
            bullet.userData = { velocity: dir.multiplyScalar(60), life: 2.0, isEnemy: false };
            worldGroup.add(bullet);
            projectiles.push(bullet);
        }

        function enemyShoot(enemy) {
            if(!gameActive) return;
            soundManager.playEnemyShoot();
            
            const sphereGeo = new THREE.SphereGeometry(0.8, 8, 8); // æ•µäººå­å½ˆè¼ƒå¤§
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // ç´…è‰²
            const bullet = new THREE.Mesh(sphereGeo, sphereMat);
            
            const startPos = enemy.mesh.position.clone();
            // ç„æº–ç©å®¶
            const targetPos = camera.position.clone();
            targetPos.y -= 2; // ç¨å¾®å¾€ä¸‹ç„æº–èº«é«”
            
            const dir = new THREE.Vector3().subVectors(targetPos, startPos).normalize();
            bullet.position.copy(startPos).add(dir.clone().multiplyScalar(4)); // å¾èº«é«”å‰æ–¹ç™¼å°„
            
            // æ•µäººå­å½ˆé€Ÿåº¦è¼ƒæ…¢ï¼Œæ–¹ä¾¿èº²é¿
            bullet.userData = { velocity: dir.multiplyScalar(30), life: 3.0, isEnemy: true };
            worldGroup.add(bullet);
            projectiles.push(bullet);
        }

        function spawnSingleEnemy() {
            const geo = new THREE.BoxGeometry(7, 7, 7);
            const mat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const eyeGeo = new THREE.BoxGeometry(1.0, 1.0, 0.5);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });

            let x, z;
            let attempts = 0;
            do {
                x = Math.floor(Math.random() * currentLevelData.size);
                z = Math.floor(Math.random() * currentLevelData.size);
                attempts++;
            } while (maze[z][x] === 1 && attempts < 100);

            if (maze[z][x] === 0) {
                const group = new THREE.Group();
                const body = new THREE.Mesh(geo, mat);
                const eyeL = new THREE.Mesh(eyeGeo, eyeMat); eyeL.position.set(-1.8, 1.0, 3.6);
                const eyeR = new THREE.Mesh(eyeGeo, eyeMat); eyeR.position.set(1.8, 1.0, 3.6);
                group.add(body, eyeL, eyeR);
                
                const px = (x - currentLevelData.size/2) * TILE_SIZE;
                const pz = (z - currentLevelData.size/2) * TILE_SIZE;
                group.position.set(px, 3.5, pz);
                group.castShadow = true;

                worldGroup.add(group);
                enemies.push({ 
                    mesh: group, 
                    hp: 3, 
                    speed: 15 + Math.random() * 10,
                    lastShot: 0
                });
            }
        }

        function spawnItems(count) {
            const geo = new THREE.BoxGeometry(2, 2, 2);
            const colors = [0xffff00, 0x00ffff, 0xff0000];
            const types = ['speed', 'slow', 'heal'];

            for(let i=0; i<count; i++) {
                let x, z;
                let attempts = 0;
                do {
                    x = Math.floor(Math.random() * currentLevelData.size);
                    z = Math.floor(Math.random() * currentLevelData.size);
                    attempts++;
                } while (maze[z][x] === 1 && attempts < 100);

                if (maze[z][x] === 0) {
                    const typeIdx = Math.floor(Math.random() * 3);
                    const mat = new THREE.MeshStandardMaterial({ 
                        color: colors[typeIdx], emissive: colors[typeIdx], emissiveIntensity: 0.5 
                    });
                    const item = new THREE.Mesh(geo, mat);
                    const px = (x - currentLevelData.size/2) * TILE_SIZE;
                    const pz = (z - currentLevelData.size/2) * TILE_SIZE;
                    item.position.set(px, 4, pz);
                    worldGroup.add(item);
                    items.push({ mesh: item, type: types[typeIdx] });
                }
            }
        }

        function updateProjectiles(dt) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const b = projectiles[i];
                const move = b.userData.velocity.clone().multiplyScalar(dt);
                b.position.add(move);
                b.userData.life -= dt;

                let hit = false;
                if (checkCollision(b.position)) hit = true;

                if (!hit) {
                    if (b.userData.isEnemy) {
                        // æ•µäººå­å½ˆæ‰“ç©å®¶
                        const playerPos = camera.position;
                        // ç°¡å–®çƒé«”åˆ¤å®š
                        if (b.position.distanceTo(playerPos) < 4) {
                            takeDamage(15);
                            hit = true;
                        }
                    } else {
                        // ç©å®¶å­å½ˆæ‰“æ•µäºº
                        for (let j = enemies.length - 1; j >= 0; j--) {
                            const enemy = enemies[j];
                            if (b.position.distanceTo(enemy.mesh.position) < 6) {
                                soundManager.playHit();
                                enemy.hp--;
                                const pushDir = b.userData.velocity.clone().normalize().multiplyScalar(5);
                                enemy.mesh.position.add(pushDir);
                                
                                if (enemy.hp <= 0) {
                                    worldGroup.remove(enemy.mesh);
                                    enemies.splice(j, 1);
                                    // é‡ç”Ÿé‚è¼¯
                                    if(currentLevel >= 3) {
                                        setTimeout(() => { if(gameActive) spawnSingleEnemy(); }, 3000); // 3ç§’å¾Œé‡ç”Ÿ
                                    }
                                } else {
                                    enemy.mesh.children[0].material.emissive.setHex(0xff0000);
                                    setTimeout(()=>enemy.mesh.children[0].material.emissive.setHex(0x000000), 100);
                                }
                                hit = true;
                                break;
                            }
                        }
                    }
                }

                if (hit || b.userData.life <= 0) {
                    worldGroup.remove(b);
                    projectiles.splice(i, 1);
                }
            }
        }

        function updateEnemies(dt, now) {
            const playerPos = camera.position;
            enemies.forEach(e => {
                e.mesh.lookAt(playerPos.x, e.mesh.position.y, playerPos.z);
                const dist = e.mesh.position.distanceTo(playerPos);
                
                // è¿½è¹¤
                if (dist < 120) { 
                    const dir = new THREE.Vector3().subVectors(playerPos, e.mesh.position).normalize();
                    dir.y = 0;
                    
                    const moveDist = e.speed * enemySpeedMulti * dt;
                    const nextPos = e.mesh.position.clone().add(dir.multiplyScalar(moveDist));
                    
                    if (!checkCollision(nextPos)) e.mesh.position.copy(nextPos);
                    
                    // æ’æ“Šå‚·å®³
                    if (dist < 6) {
                        takeDamage(10);
                        e.mesh.position.sub(dir.multiplyScalar(8)); 
                    }

                    // å°„æ“Šé‚è¼¯ (Level 3+)
                    if (currentLevel >= 3 && now - e.lastShot > 2000 && dist < 80) { // 2ç§’å†·å»
                        // ç°¡å–®è¦–ç·šæª¢æŸ¥ (ä¸ç©¿ç‰†)
                        // é€™è£¡çœç•¥è¤‡é›œçš„å…‰ç·šæŠ•å°„ï¼Œç›´æ¥ç™¼å°„
                        enemyShoot(e);
                        e.lastShot = now;
                    }
                }
                e.mesh.scale.setScalar(1 + Math.sin(now * 0.01) * 0.1);
            });
        }

        function updateItems(dt) {
            const playerPos = camera.position;
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                item.mesh.rotation.y += dt;
                item.mesh.position.y = 4 + Math.sin(Date.now() * 0.005);

                // ä¿®æ­£åˆ¤å®šï¼šåªçœ‹ XZ å¹³é¢è·é›¢ï¼Œç„¡è¦–é«˜åº¦å·®
                const dx = item.mesh.position.x - playerPos.x;
                const dz = item.mesh.position.z - playerPos.z;
                const dist2d = Math.sqrt(dx*dx + dz*dz);

                if (dist2d < 6) { // åŠ å¤§æ’¿å–ç¯„åœ
                    applyEffect(item.type);
                    worldGroup.remove(item.mesh);
                    items.splice(i, 1);
                }
            }
        }

        function takeDamage(amount) {
            if (playerStats.invincible > 0) return;
            playerStats.hp -= amount;
            soundManager.playDamage();
            updateHPBar();
            scene.background = new THREE.Color(0x550000);
            setTimeout(() => scene.background = new THREE.Color(0x87CEEB), 100);
            playerStats.invincible = 1.0; 
            if (playerStats.hp <= 0) gameOver(false, "ä½ å€’ä¸‹äº†ï¼");
        }

        function applyEffect(type) {
            soundManager.playPowerUp();
            const statusDiv = document.getElementById('status-effects');
            
            if (type === 'heal') {
                playerStats.hp = Math.min(playerStats.hp + 30, playerStats.maxHp);
                updateHPBar();
                showStatusText("â¤ï¸ æ¢å¾©ç”Ÿå‘½");
            } else if (type === 'speed') {
                playerStats.speedMulti = 1.8;
                showStatusText("âš¡ é€Ÿåº¦æå‡!");
                setTimeout(() => { playerStats.speedMulti = 1.0; updateStatusEffects(); }, 8000);
            } else if (type === 'slow') {
                enemySpeedMulti = 0.3;
                showStatusText("â„ï¸ æ€ªç‰©å‡çµ!");
                setTimeout(() => { enemySpeedMulti = 1.0; updateStatusEffects(); }, 8000);
            }
            updateStatusEffects();
        }

        function showStatusText(text) {
            // Placeholder for floating text
        }

        function updateStatusEffects() {
            const div = document.getElementById('status-effects');
            div.innerHTML = '';
            if (playerStats.speedMulti > 1) div.innerHTML += '<div class="effect-badge" style="background:#f1c40f; color:#000;">âš¡åŠ é€Ÿä¸­</div>';
            if (enemySpeedMulti < 1) div.innerHTML += '<div class="effect-badge" style="background:#3498db; color:#fff;">â„ï¸å‡çµä¸­</div>';
        }

        function updateHPBar() {
            const bar = document.getElementById('health-bar');
            const txt = document.getElementById('health-text');
            const pct = Math.max(0, (playerStats.hp / playerStats.maxHp) * 100);
            bar.style.width = pct + '%';
            txt.innerText = `HP: ${playerStats.hp}/${playerStats.maxHp}`;
        }

        function createBrickTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#a0a0a0'; ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#c0392b';
            for(let y=0; y<128; y+=18) {
                const off = (y/18)%2===0?0:16;
                for(let x=-16; x<128; x+=34) ctx.fillRect(x+off, y, 32, 16);
            }
            ctx.fillStyle = '#87CEEB'; ctx.fillRect(32,32,64,64);
            ctx.strokeStyle='#fff'; ctx.lineWidth=4; ctx.strokeRect(32,32,64,64);
            return new THREE.CanvasTexture(canvas);
        }

        function createPaverTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d'); ctx.fillStyle = '#7f8c8d'; ctx.fillRect(0,0,64,64);
            ctx.strokeStyle = '#636e72'; ctx.strokeRect(0,0,64,64);
            return new THREE.CanvasTexture(canvas);
        }

        function createMazeWorld(mazeSize) {
            maze = Array(mazeSize).fill().map(() => Array(mazeSize).fill(1));
            function carve(x, y) {
                const dirs = [[1,0], [-1,0], [0,1], [0,-1]].sort(() => Math.random()-0.5);
                dirs.forEach(([dx, dy]) => {
                    const nx = x + dx*2, ny = y + dy*2;
                    if (nx > 0 && nx < mazeSize-1 && ny > 0 && ny < mazeSize-1 && maze[ny][nx] === 1) {
                        maze[y+dy][x+dx] = 0; maze[ny][nx] = 0; carve(nx, ny);
                    }
                });
            }
            maze[1][1] = 0; carve(1,1);

            const floorSize = mazeSize * TILE_SIZE * 1.5;
            const floorMat = new THREE.MeshStandardMaterial({ map: createPaverTexture(), roughness: 0.8 });
            floorMat.map.repeat.set(floorSize/20, floorSize/20); floorMat.map.wrapS = floorMat.map.wrapT = THREE.RepeatWrapping;
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(floorSize, floorSize), floorMat);
            floor.rotation.x = -Math.PI/2; floor.receiveShadow = true;
            worldGroup.add(floor);

            const boxGeo = new THREE.BoxGeometry(TILE_SIZE, WALL_HEIGHT, TILE_SIZE);
            const wallMat = new THREE.MeshStandardMaterial({ map: createBrickTexture() });

            for(let y=0; y<mazeSize; y++){
                for(let x=0; x<mazeSize; x++){
                    const px = (x - mazeSize/2) * TILE_SIZE;
                    const pz = (y - mazeSize/2) * TILE_SIZE;
                    if(maze[y][x] === 1) {
                        const wall = new THREE.Mesh(boxGeo, wallMat);
                        wall.position.set(px, WALL_HEIGHT/2, pz);
                        wall.castShadow = true; wall.receiveShadow = true;
                        worldGroup.add(wall);
                    }
                }
            }

            maze[1][1] = 0; 
            camera.position.set((1 - mazeSize / 2) * TILE_SIZE, 8, (1 - mazeSize / 2) * TILE_SIZE);
            camera.rotation.y = Math.PI;

            let ex = mazeSize-2, ey = mazeSize-2;
            if(maze[ey][ex]===1) { ex=1; ey=mazeSize-2; }
            exitPosition.set((ex-mazeSize/2)*TILE_SIZE, 0, (ey-mazeSize/2)*TILE_SIZE);

            const exitGeo = new THREE.BoxGeometry(4, 100, 4);
            const exitMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.6 });
            const exitMark = new THREE.Mesh(exitGeo, exitMat);
            exitMark.position.copy(exitPosition); exitMark.position.y=50;
            worldGroup.add(exitMark);
        }

        function checkWinCondition() {
            const pos = camera.position;
            const dist = Math.hypot(pos.x - exitPosition.x, pos.z - exitPosition.z);
            if(dist < 10) gameOver(true, "éé—œï¼");
        }

        function gameOver(win, message) {
            gameActive = false;
            clearInterval(timerInterval);
            const screen = document.getElementById('result-screen');
            const title = document.getElementById('result-title');
            const msg = document.getElementById('result-message');
            const btn = document.getElementById('action-btn');
            
            screen.style.display = 'flex';
            msg.innerText = message;

            if (win) {
                soundManager.playWin();
                if (currentLevel >= 100) {
                    title.innerText = "ğŸ† å‚³å¥‡èª•ç”Ÿï¼";
                    title.className = "win-text";
                    msg.innerText = "ä½ å¾æœäº† 100 å±¤è¿·å®®ï¼";
                    btn.innerText = "é‡æ–°é–‹å§‹";
                    btn.className = "action-btn btn-next";
                } else {
                    title.innerText = "ğŸ‰ é€ƒè„«æˆåŠŸï¼";
                    title.className = "win-text";
                    btn.innerText = "ä¸‹ä¸€é—œ >>";
                    btn.className = "action-btn btn-next";
                }
            } else {
                soundManager.playLose();
                title.innerText = "ğŸ’€ ä»»å‹™å¤±æ•—";
                title.className = "lose-text";
                btn.innerText = "é‡è©¦æœ¬é—œ";
                btn.className = "action-btn btn-retry";
            }
        }

        function checkCollision(pos) {
            const pX = pos.x; const pZ = pos.z; const r = 1.5; 
            const checks = [{x:pX+r, z:pZ}, {x:pX-r, z:pZ}, {x:pX, z:pZ+r}, {x:pX, z:pZ-r}];
            const ms = currentLevelData.size;
            for (let p of checks) {
                const gx = Math.round((p.x / TILE_SIZE) + (ms / 2));
                const gy = Math.round((p.z / TILE_SIZE) + (ms / 2));
                if (gx >= 0 && gx < ms && gy >= 0 && gy < ms) {
                    if (maze[gy][gx] === 1) return true;
                }
            }
            return false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1); 
            prevTime = time;

            if (gameActive) {
                if (playerStats.invincible > 0) playerStats.invincible -= delta;

                updateProjectiles(delta);
                updateEnemies(delta, time); // å‚³å…¥ time ç”¨æ–¼å°„æ“Šå†·å»
                updateItems(delta);

                if (rotateLeft) camera.rotation.y += ROTATE_SPEED * delta;
                if (rotateRight) camera.rotation.y -= ROTATE_SPEED * delta;

                let moveSpeed = 0;
                const finalSpeed = PLAYER_BASE_SPEED * playerStats.speedMulti;
                
                if (moveForward) moveSpeed = finalSpeed * delta;
                if (moveBackward) moveSpeed = -finalSpeed * delta;

                if (moveSpeed !== 0) {
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    forward.y = 0; forward.normalize();
                    const currentPos = camera.position.clone();
                    const nextX = currentPos.x + forward.x * moveSpeed;
                    const nextZ = currentPos.z + forward.z * moveSpeed;

                    if (!checkCollision(new THREE.Vector3(nextX, currentPos.y, currentPos.z))) camera.position.x = nextX;
                    if (!checkCollision(new THREE.Vector3(camera.position.x, currentPos.y, nextZ))) camera.position.z = nextZ;
                }
                checkWinCondition();
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
