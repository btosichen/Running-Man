<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ ¡åœ’è¿·å®®é€ƒè„« (ç”Ÿå­˜æˆ°é¬¥ç‰ˆ)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #87CEEB;
            user-select: none;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        #hud {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            color: #fff;
            text-shadow: 3px 3px 0px #000;
            font-family: 'Arial Black', sans-serif;
            background: linear-gradient(to bottom, rgba(0,0,0,0.4), transparent);
        }
        
        /* è¡€æ¢æ¨£å¼ */
        #health-container {
            width: 300px;
            height: 30px;
            background: #333;
            border: 4px solid #fff;
            border-radius: 15px;
            overflow: hidden;
            margin-top: 10px;
            position: relative;
        }
        #health-bar {
            width: 100%;
            height: 100%;
            background: #e74c3c;
            transition: width 0.2s;
        }
        #health-text {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            font-size: 18px; text-shadow: 1px 1px 0 #000;
        }

        #status-effects {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }
        .effect-badge {
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
            animation: pulse 1s infinite;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        #input-debug {
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            pointer-events: none;
            opacity: 0.9;
        }
        .key-row { display: flex; gap: 8px; }
        .key-icon {
            width: 45px; height: 45px;
            background: #fff; border-bottom: 4px solid #ccc; color: #333;
            display: flex; align-items: center; justify-content: center;
            font-weight: 900; border-radius: 8px; font-family: 'Arial Black', sans-serif;
            font-size: 20px; transition: all 0.1s;
        }
        .key-active { background: #f39c12; border-bottom: 0px solid #d35400; transform: translateY(4px); color: white; }
        .key-space { width: 150px; } /* ç©ºç™½éµé•·ä¸€é» */

        #blocker {
            position: absolute; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7); backdrop-filter: blur(5px);
            display: flex; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 10;
        }
        #instructions {
            width: 600px; padding: 40px;
            background: linear-gradient(135deg, #ffffff, #f0f0f0);
            border-radius: 20px; text-align: center; color: #333;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5); border: 5px solid #fff;
        }
        h1 { margin: 0 0 10px 0; color: #c0392b; font-size: 42px; font-family: 'Arial Black', sans-serif; letter-spacing: -1px; }
        p { font-size: 18px; margin: 8px 0; color: #555; font-weight: bold; }
        .key { background: #fff; color: #333; padding: 4px 10px; border: 2px solid #ccc; border-radius: 6px; font-weight: 900; font-family: monospace; display: inline-block; box-shadow: 0 2px 0 #bbb; }
        
        #start-btn {
            background: #2ecc71; color: white; font-size: 28px; padding: 15px 60px;
            border: none; border-radius: 15px; cursor: pointer; margin-top: 25px;
            box-shadow: 0 6px 0 #27ae60; transition: transform 0.1s;
            font-weight: 900; font-family: 'Arial Black', sans-serif; text-transform: uppercase;
        }
        #start-btn:active { transform: translateY(6px); box-shadow: 0 0 0 #27ae60; }
        #start-btn:hover { background: #27ae60; }

        #result-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 10, 10, 0.95); color: white; z-index: 20;
            flex-direction: column; align-items: center; justify-content: center;
            text-align: center; pointer-events: auto;
        }
        button.action-btn {
            padding: 20px 50px; font-size: 24px; color: white; border: none; border-radius: 15px;
            cursor: pointer; margin-top: 30px; box-shadow: 0 6px 0 rgba(0,0,0,0.2);
            transition: transform 0.1s; font-weight: bold; font-family: 'Arial Black', sans-serif;
        }
        .btn-next { background: #3498db; box-shadow: 0 6px 0 #2980b9; }
        .btn-retry { background: #e74c3c; box-shadow: 0 6px 0 #c0392b; }
        .btn-next:active, .btn-retry:active { transform: translateY(6px); box-shadow: none; }
        
        .win-text { color: #2ecc71; font-size: 60px; text-shadow: 4px 4px 0 #27ae60; font-family: 'Arial Black', sans-serif; }
        .lose-text { color: #e74c3c; font-size: 60px; text-shadow: 4px 4px 0 #c0392b; font-family: 'Arial Black', sans-serif; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="hud">
            <div>
                <div style="font-size: 32px; color: #f1c40f;">Level <span id="level-num">1</span></div>
                <div id="time-display">â° 05:00</div>
                <div id="status-effects"></div>
            </div>
            <div style="text-align: right;">
                <div id="status">å°‹æ‰¾ç¶ è‰²å…‰æŸ±</div>
                <div id="health-container">
                    <div id="health-bar"></div>
                    <div id="health-text">HP: 100/100</div>
                </div>
            </div>
        </div>
        <div id="input-debug">
            <div class="key-row">
                <div id="key-w" class="key-icon">W</div>
            </div>
            <div class="key-row">
                <div id="key-a" class="key-icon">A</div>
                <div id="key-s" class="key-icon">S</div>
                <div id="key-d" class="key-icon">D</div>
            </div>
            <div class="key-row">
                <div id="key-space" class="key-icon key-space">SPACE (æ”»æ“Š)</div>
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="blocker">
        <div id="instructions">
            <h1 id="menu-title">æ ¡åœ’ç”Ÿå­˜é€ƒè„«</h1>
            <p id="menu-subtitle">æ€ªç‰©å…¥ä¾µæ ¡åœ’ï¼æ‹¿èµ·æœ¨æ£’åæ“Šï¼</p>
            <hr style="border: 2px dashed #ddd; margin: 20px 0;">
            <p><span class="key">W</span> <span class="key">S</span> ç§»å‹• &nbsp; <span class="key">A</span> <span class="key">D</span> è½‰å‘</p>
            <p><span class="key" style="width: 100px;">SPACE</span> ç™¼å°„é­”æ³•å½ˆ</p>
            <p>âš¡åŠ é€Ÿ &nbsp; â„ï¸ç·©é€Ÿæ•µäºº &nbsp; â¤ï¸è£œè¡€</p>
            <br>
            <button id="start-btn">é–‹å§‹ç”Ÿå­˜</button>
            <p style="font-size: 14px; margin-top: 15px; color: #e74c3c;">âš ï¸ è«‹ç¢ºèªè¼¸å…¥æ³•ç‚ºè‹±æ–‡</p>
        </div>
    </div>

    <div id="result-screen">
        <div id="result-title" class="win-text"></div>
        <p id="result-message" style="font-size: 24px; margin: 20px; color: #ddd; font-weight: bold;"></p>
        <button id="action-btn" class="action-btn" onclick="handleAction()">ä¸‹ä¸€é—œ</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- é—œå¡è¨­å®š ---
        const LEVELS = [
            { id: 1, size: 15, time: 300, enemies: 6 },  // æ™‚é–“æ”¹ç‚º 300ç§’ (5åˆ†é˜)ï¼Œæ•µäººåŠ å€
            { id: 2, size: 17, time: 300, enemies: 10 },
            { id: 3, size: 19, time: 300, enemies: 14 },
            { id: 4, size: 21, time: 320, enemies: 18 },
            { id: 5, size: 23, time: 340, enemies: 24 },
            { id: 6, size: 25, time: 360, enemies: 30 },
            { id: 7, size: 27, time: 380, enemies: 36 },
            { id: 8, size: 29, time: 400, enemies: 40 },
            { id: 9, size: 31, time: 420, enemies: 50 },
            { id: 10, size: 33, time: 450, enemies: 60 }
        ];

        let currentLevelIndex = 0;
        let currentLevelData = LEVELS[0];

        // --- éŸ³æ•ˆç®¡ç†å™¨ ---
        class SoundManager {
            constructor() {
                this.ctx = null;
                this.isPlaying = false;
            }
            init() {
                if(!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                }
                if(this.ctx.state === 'suspended') this.ctx.resume();
                this.startBGM();
                this.isPlaying = true;
            }
            playTone(freq, type, duration, vol = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + duration);
            }
            playNoise(duration, vol) {
                if (!this.ctx) return;
                const bufferSize = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                noise.connect(gain); gain.connect(this.ctx.destination);
                noise.start();
            }
            startBGM() { /* ç°¡åŒ– BGM ä»¥ä¾¿åŠ å…¥éŸ³æ•ˆ */ 
                if(!this.ctx) return;
                // èƒŒæ™¯ä½é »å—¡å—¡è²ï¼Œç‡Ÿé€ ç·Šå¼µæ„Ÿ
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.value = 50;
                gain.gain.value = 0.02;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass'; filter.frequency.value = 200;
                osc.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
                osc.start();
            }
            playShoot() { this.playTone(600, 'square', 0.1, 0.1); setTimeout(()=>this.playTone(300, 'square', 0.1, 0.1), 50); }
            playHit() { this.playNoise(0.1, 0.2); }
            playPowerUp() { this.playTone(1000, 'sine', 0.2, 0.2); setTimeout(()=>this.playTone(1500, 'sine', 0.3, 0.2), 100); }
            playDamage() { this.playTone(100, 'sawtooth', 0.3, 0.3); }
            playWin() { [523, 659, 784, 1046].forEach((f,i)=>setTimeout(()=>this.playTone(f,'square',0.2,0.2),i*100)); }
            playLose() { this.playTone(200,'sawtooth',0.5,0.3); setTimeout(()=>this.playTone(100,'sawtooth',1.0,0.3),400); }
        }
        const soundManager = new SoundManager();

        // --- å…¨åŸŸè®Šæ•¸ ---
        let camera, scene, renderer;
        let worldGroup = new THREE.Group();
        
        // ç©å®¶ç‹€æ…‹
        let playerStats = { hp: 100, maxHp: 100, speedMulti: 1.0, invincible: 0 };
        const PLAYER_BASE_SPEED = 250.0;
        const ROTATE_SPEED = 2.0;
        let weaponMesh;
        let projectiles = [];
        
        // è¼¸å…¥
        let moveForward = false, moveBackward = false, rotateLeft = false, rotateRight = false;
        
        // éŠæˆ²ç‰©ä»¶
        let enemies = [];
        let items = [];
        let maze = [];
        let exitPosition = new THREE.Vector3();
        
        // éŠæˆ²å¾ªç’°
        let prevTime = performance.now();
        const TILE_SIZE = 25;
        const WALL_HEIGHT = 20;
        let gameActive = false;
        let timeLeft = 0;
        let timerInterval;

        // ç‰¹æ®Šæ•ˆæœ
        let enemySpeedMulti = 1.0;

        window.handleAction = function() {
            const btn = document.getElementById('action-btn');
            const resultScreen = document.getElementById('result-screen');
            if (btn.classList.contains('btn-next')) {
                currentLevelIndex++;
                if (currentLevelIndex >= LEVELS.length) {
                    location.reload();
                } else {
                    resultScreen.style.display = 'none';
                    startLevel(currentLevelIndex);
                }
            } else {
                resultScreen.style.display = 'none';
                startLevel(currentLevelIndex);
            }
        };

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 250);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
            camera.rotation.order = 'YXZ'; 

            // æ­¦å™¨ (åŠ åœ¨ç›¸æ©Ÿä¸Š)
            const weaponGeo = new THREE.BoxGeometry(0.5, 0.5, 4);
            const weaponMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // æœ¨æ£’
            weaponMesh = new THREE.Mesh(weaponGeo, weaponMat);
            weaponMesh.position.set(1.5, -1.5, -2); // å³ä¸‹æ–¹
            weaponMesh.rotation.x = -0.2;
            weaponMesh.rotation.y = -0.2;
            camera.add(weaponMesh);
            scene.add(camera);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
            sunLight.position.set(100, 200, 100);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048; sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.left = -300; sunLight.shadow.camera.right = 300;
            sunLight.shadow.camera.top = 300; sunLight.shadow.camera.bottom = -300;
            scene.add(sunLight);
            scene.add(worldGroup);

            // UI Listeners
            document.getElementById('start-btn').addEventListener('click', () => {
                document.getElementById('blocker').style.display = 'none';
                soundManager.init();
                startLevel(0);
            });

            // Controls
            const onKeyDown = (e) => {
                const k = e.key.toLowerCase(), c = e.code;
                if(c==='ArrowUp'||c==='KeyW'||k==='w') { moveForward=true; document.getElementById('key-w').classList.add('key-active'); }
                if(c==='ArrowDown'||c==='KeyS'||k==='s') { moveBackward=true; document.getElementById('key-s').classList.add('key-active'); }
                if(c==='ArrowLeft'||c==='KeyA'||k==='a') { rotateLeft=true; document.getElementById('key-a').classList.add('key-active'); }
                if(c==='ArrowRight'||c==='KeyD'||k==='d') { rotateRight=true; document.getElementById('key-d').classList.add('key-active'); }
                if(c==='Space'||k===' ') { shoot(); document.getElementById('key-space').classList.add('key-active'); }
            };
            const onKeyUp = (e) => {
                const k = e.key.toLowerCase(), c = e.code;
                if(c==='ArrowUp'||c==='KeyW'||k==='w') { moveForward=false; document.getElementById('key-w').classList.remove('key-active'); }
                if(c==='ArrowDown'||c==='KeyS'||k==='s') { moveBackward=false; document.getElementById('key-s').classList.remove('key-active'); }
                if(c==='ArrowLeft'||c==='KeyA'||k==='a') { rotateLeft=false; document.getElementById('key-a').classList.remove('key-active'); }
                if(c==='ArrowRight'||c==='KeyD'||k==='d') { rotateRight=false; document.getElementById('key-d').classList.remove('key-active'); }
                if(c==='Space'||k===' ') { document.getElementById('key-space').classList.remove('key-active'); }
            };
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', onWindowResize);
        }

        function startLevel(index) {
            currentLevelIndex = index;
            currentLevelData = LEVELS[index];

            // Reset Game
            while(worldGroup.children.length > 0) worldGroup.remove(worldGroup.children[0]);
            enemies = [];
            items = [];
            projectiles = [];
            
            playerStats.hp = playerStats.maxHp;
            playerStats.speedMulti = 1.0;
            playerStats.invincible = 0;
            enemySpeedMulti = 1.0;
            updateHPBar();
            updateStatusEffects();

            document.getElementById('level-num').innerText = currentLevelData.id;
            timeLeft = currentLevelData.time;
            updateTimeDisplay();

            createMazeWorld(currentLevelData.size);

            // Spawn Entities
            spawnEnemies(currentLevelData.enemies);
            spawnItems(5); // æ¯é—œ 5 å€‹é“å…·

            moveForward = false; moveBackward = false; rotateLeft = false; rotateRight = false;
            prevTime = performance.now();
            gameActive = true;

            if(timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if(!gameActive) return;
                timeLeft--;
                updateTimeDisplay();
                if(timeLeft <= 0) gameOver(false, "æ™‚é–“è€—ç›¡ï¼");
            }, 1000);
        }

        function updateTimeDisplay() {
            const m = Math.floor(timeLeft/60).toString().padStart(2,'0');
            const s = (timeLeft%60).toString().padStart(2,'0');
            document.getElementById('time-display').innerText = `â° ${m}:${s}`;
        }

        // --- æˆ°é¬¥èˆ‡é“å…·ç³»çµ± ---

        function shoot() {
            if(!gameActive) return;
            soundManager.playShoot();

            // æ­¦å™¨å‹•ç•«
            weaponMesh.position.z = -1; // å¾Œåº§åŠ›
            setTimeout(() => weaponMesh.position.z = -2, 100);

            // ç”¢ç”Ÿå­å½ˆ
            const sphereGeo = new THREE.SphereGeometry(0.5, 8, 8);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(sphereGeo, sphereMat);
            
            // å­å½ˆä½ç½®èˆ‡æ–¹å‘
            const pos = new THREE.Vector3();
            const quat = new THREE.Quaternion();
            camera.getWorldPosition(pos);
            camera.getWorldQuaternion(quat);
            
            // ç¨å¾®å¾€ä¸‹å‰ä¸€é»
            const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(quat).normalize();
            bullet.position.copy(pos).add(dir.clone().multiplyScalar(2));
            
            bullet.userData = { velocity: dir.multiplyScalar(60), life: 2.0 }; // é€Ÿåº¦ 60
            worldGroup.add(bullet);
            projectiles.push(bullet);
        }

        function spawnItems(count) {
            const geo = new THREE.BoxGeometry(2, 2, 2);
            // 0: Speed (Yellow), 1: Slow (Blue), 2: Heal (Red)
            const colors = [0xffff00, 0x00ffff, 0xff0000];
            const types = ['speed', 'slow', 'heal'];

            for(let i=0; i<count; i++) {
                let x, z;
                let attempts = 0;
                do {
                    x = Math.floor(Math.random() * currentLevelData.size);
                    z = Math.floor(Math.random() * currentLevelData.size);
                    attempts++;
                } while (maze[z][x] === 1 && attempts < 100);

                if (maze[z][x] === 0) {
                    const typeIdx = Math.floor(Math.random() * 3);
                    const mat = new THREE.MeshStandardMaterial({ 
                        color: colors[typeIdx], 
                        emissive: colors[typeIdx], 
                        emissiveIntensity: 0.5 
                    });
                    const item = new THREE.Mesh(geo, mat);
                    
                    const px = (x - currentLevelData.size/2) * TILE_SIZE;
                    const pz = (z - currentLevelData.size/2) * TILE_SIZE;
                    item.position.set(px, 4, pz);
                    
                    worldGroup.add(item);
                    items.push({ mesh: item, type: types[typeIdx] });
                }
            }
        }

        // --- é‚è¼¯æ›´æ–° ---

        function updateProjectiles(dt) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const b = projectiles[i];
                const move = b.userData.velocity.clone().multiplyScalar(dt);
                b.position.add(move);
                b.userData.life -= dt;

                let hit = false;

                // æ’ç‰†æª¢æŸ¥
                if (checkCollision(b.position)) hit = true;

                // æ’æ•µäººæª¢æŸ¥
                if (!hit) {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        // åˆ¤å®šç¯„åœåŠ å¤§ï¼šå› ç‚ºæ•µäººè®Šå¤§äº† (7x7x7)ï¼Œåˆ¤å®šè·é›¢è¨­ç‚º 6 æ¯”è¼ƒå®¹æ˜“æ‰“ä¸­
                        if (b.position.distanceTo(enemy.mesh.position) < 6) {
                            soundManager.playHit();
                            enemy.hp--;
                            // æ“Šé€€æ•ˆæœ
                            const pushDir = b.userData.velocity.clone().normalize().multiplyScalar(5);
                            enemy.mesh.position.add(pushDir);
                            
                            // æ•µäººæ­»äº¡
                            if (enemy.hp <= 0) {
                                worldGroup.remove(enemy.mesh);
                                enemies.splice(j, 1);
                            } else {
                                // å—å‚·é–ƒçˆ
                                enemy.mesh.children[0].material.emissive.setHex(0xff0000);
                                setTimeout(()=>enemy.mesh.children[0].material.emissive.setHex(0x000000), 100);
                            }
                            hit = true;
                            break;
                        }
                    }
                }

                if (hit || b.userData.life <= 0) {
                    worldGroup.remove(b);
                    projectiles.splice(i, 1);
                }
            }
        }

        function updateEnemies(dt) {
            const playerPos = camera.position;
            enemies.forEach(e => {
                // è½‰å‘ç©å®¶
                e.mesh.lookAt(playerPos.x, e.mesh.position.y, playerPos.z);
                
                // ç°¡å–®è¿½è¹¤ AI
                const dist = e.mesh.position.distanceTo(playerPos);
                if (dist < 100) { // è¦–é‡ç¯„åœåŠ å¤§
                    const dir = new THREE.Vector3().subVectors(playerPos, e.mesh.position).normalize();
                    // å¿½ç•¥Yè»¸
                    dir.y = 0;
                    
                    const moveDist = e.speed * enemySpeedMulti * dt;
                    const nextPos = e.mesh.position.clone().add(dir.multiplyScalar(moveDist));
                    
                    // æ•µäººç¢°æ’ç‰†å£æª¢æ¸¬
                    if (!checkCollision(nextPos)) {
                        e.mesh.position.copy(nextPos);
                    }
                    
                    // æ”»æ“Šç©å®¶ (åˆ¤å®šç¯„åœåŠ å¤§ï¼Œå› ç‚ºæ•µäººå¾ˆå¤§éš»)
                    if (dist < 6) {
                        takeDamage(10);
                        // ç°¡å–®ç¢°æ’å¾Œé€€ï¼Œé¿å…é»ä½
                        e.mesh.position.sub(dir.multiplyScalar(8)); 
                    }
                }
                
                // å‘¼å¸å‹•ç•«
                e.mesh.scale.setScalar(1 + Math.sin(Date.now() * 0.01) * 0.1);
            });
        }
        function spawnEnemies(count) {
            // æ•µäººè®Šå¤§ï¼šå¾ 3x3x3 è®Šæˆ 7x7x7
            const geo = new THREE.BoxGeometry(7, 7, 7);
            const mat = new THREE.MeshStandardMaterial({ color: 0x000000 }); // é»‘è‰²æœ¬é«”
            // çœ¼ç›ä¹Ÿè¦èª¿æ•´ä½ç½®
            const eyeGeo = new THREE.BoxGeometry(1.0, 1.0, 0.5);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // ç´…çœ¼

            for(let i=0; i<count; i++) {
                // æ‰¾ç©ºåœ°
                let x, z;
                let attempts = 0;
                do {
                    x = Math.floor(Math.random() * currentLevelData.size);
                    z = Math.floor(Math.random() * currentLevelData.size);
                    attempts++;
                } while (maze[z][x] === 1 && attempts < 100);

                if (maze[z][x] === 0) {
                    const group = new THREE.Group();
                    const body = new THREE.Mesh(geo, mat);
                    // èª¿æ•´çœ¼ç›ä½ç½®ä»¥é©æ‡‰å¤§èº«é«”
                    const eyeL = new THREE.Mesh(eyeGeo, eyeMat); eyeL.position.set(-1.8, 1.0, 3.6);
                    const eyeR = new THREE.Mesh(eyeGeo, eyeMat); eyeR.position.set(1.8, 1.0, 3.6);
                    group.add(body, eyeL, eyeR);
                    
                    const px = (x - currentLevelData.size/2) * TILE_SIZE;
                    const pz = (z - currentLevelData.size/2) * TILE_SIZE;
                    // Yè»¸ä½ç½®èª¿æ•´ï¼Œç¢ºä¿ç«™åœ¨åœ°æ¿ä¸Š (7/2 = 3.5)
                    group.position.set(px, 3.5, pz);
                    group.castShadow = true;

                    worldGroup.add(group);
                    enemies.push({ 
                        mesh: group, 
                        hp: 3, 
                        speed: 15 + Math.random() * 10 
                    });
                }
            }
        }

        function updateItems(dt) {
            const playerPos = camera.position;
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                item.mesh.rotation.y += dt;
                item.mesh.position.y = 4 + Math.sin(Date.now() * 0.005);

                if (item.mesh.position.distanceTo(playerPos) < 4) {
                    applyEffect(item.type);
                    worldGroup.remove(item.mesh);
                    items.splice(i, 1);
                }
            }
        }

        function takeDamage(amount) {
            if (playerStats.invincible > 0) return;
            
            playerStats.hp -= amount;
            soundManager.playDamage();
            updateHPBar();

            // å—å‚·ç´…å±æ•ˆæœ (ç°¡å–®æ¨¡æ“¬)
            scene.background = new THREE.Color(0x550000);
            setTimeout(() => scene.background = new THREE.Color(0x87CEEB), 100);

            // ç„¡æ•µæ™‚é–“
            playerStats.invincible = 1.0; 

            if (playerStats.hp <= 0) {
                gameOver(false, "ä½ è¢«æ€ªç‰©æ“Šå€’äº†ï¼");
            }
        }

        function applyEffect(type) {
            soundManager.playPowerUp();
            const statusDiv = document.getElementById('status-effects');
            
            if (type === 'heal') {
                playerStats.hp = Math.min(playerStats.hp + 30, playerStats.maxHp);
                updateHPBar();
                showStatusText("â¤ï¸ æ¢å¾©ç”Ÿå‘½");
            } else if (type === 'speed') {
                playerStats.speedMulti = 1.8;
                showStatusText("âš¡ é€Ÿåº¦æå‡!");
                setTimeout(() => { playerStats.speedMulti = 1.0; updateStatusEffects(); }, 8000);
            } else if (type === 'slow') {
                enemySpeedMulti = 0.3;
                showStatusText("â„ï¸ æ€ªç‰©å‡çµ!");
                setTimeout(() => { enemySpeedMulti = 1.0; updateStatusEffects(); }, 8000);
            }
            updateStatusEffects();
        }

        function showStatusText(text) {
            // ç°¡å–®çš„æµ®å‹•æ–‡å­—æ•ˆæœå¯ä»¥åŠ åœ¨é€™è£¡ï¼Œç›®å‰ç”¨ UI é¡¯ç¤º
        }

        function updateStatusEffects() {
            const div = document.getElementById('status-effects');
            div.innerHTML = '';
            if (playerStats.speedMulti > 1) {
                div.innerHTML += '<div class="effect-badge" style="background:#f1c40f; color:#000;">âš¡åŠ é€Ÿä¸­</div>';
            }
            if (enemySpeedMulti < 1) {
                div.innerHTML += '<div class="effect-badge" style="background:#3498db; color:#fff;">â„ï¸å‡çµä¸­</div>';
            }
        }

        function updateHPBar() {
            const bar = document.getElementById('health-bar');
            const txt = document.getElementById('health-text');
            const pct = (playerStats.hp / playerStats.maxHp) * 100;
            bar.style.width = pct + '%';
            txt.innerText = `HP: ${playerStats.hp}/${playerStats.maxHp}`;
        }

        // --- è¿·å®®ç”Ÿæˆ (æ²¿ç”¨) ---
        function createBrickTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#a0a0a0'; ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#c0392b';
            for(let y=0; y<128; y+=18) {
                const off = (y/18)%2===0?0:16;
                for(let x=-16; x<128; x+=34) ctx.fillRect(x+off, y, 32, 16);
            }
            ctx.fillStyle = '#87CEEB'; ctx.fillRect(32,32,64,64);
            ctx.strokeStyle='#fff'; ctx.lineWidth=4; ctx.strokeRect(32,32,64,64);
            return new THREE.CanvasTexture(canvas);
        }

        function createPaverTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d'); ctx.fillStyle = '#7f8c8d'; ctx.fillRect(0,0,64,64);
            ctx.strokeStyle = '#636e72'; ctx.strokeRect(0,0,64,64);
            return new THREE.CanvasTexture(canvas);
        }

        function createMazeWorld(mazeSize) {
            maze = Array(mazeSize).fill().map(() => Array(mazeSize).fill(1));
            function carve(x, y) {
                const dirs = [[1,0], [-1,0], [0,1], [0,-1]].sort(() => Math.random()-0.5);
                dirs.forEach(([dx, dy]) => {
                    const nx = x + dx*2, ny = y + dy*2;
                    if (nx > 0 && nx < mazeSize-1 && ny > 0 && ny < mazeSize-1 && maze[ny][nx] === 1) {
                        maze[y+dy][x+dx] = 0; maze[ny][nx] = 0; carve(nx, ny);
                    }
                });
            }
            maze[1][1] = 0; carve(1,1);

            const floorSize = mazeSize * TILE_SIZE * 1.5;
            const floorMat = new THREE.MeshStandardMaterial({ map: createPaverTexture(), roughness: 0.8 });
            floorMat.map.repeat.set(floorSize/20, floorSize/20); floorMat.map.wrapS = floorMat.map.wrapT = THREE.RepeatWrapping;
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(floorSize, floorSize), floorMat);
            floor.rotation.x = -Math.PI/2; floor.receiveShadow = true;
            worldGroup.add(floor);

            const boxGeo = new THREE.BoxGeometry(TILE_SIZE, WALL_HEIGHT, TILE_SIZE);
            const wallMat = new THREE.MeshStandardMaterial({ map: createBrickTexture() });

            for(let y=0; y<mazeSize; y++){
                for(let x=0; x<mazeSize; x++){
                    const px = (x - mazeSize/2) * TILE_SIZE;
                    const pz = (y - mazeSize/2) * TILE_SIZE;
                    if(maze[y][x] === 1) {
                        const wall = new THREE.Mesh(boxGeo, wallMat);
                        wall.position.set(px, WALL_HEIGHT/2, pz);
                        wall.castShadow = true; wall.receiveShadow = true;
                        worldGroup.add(wall);
                    }
                }
            }

            maze[1][1] = 0; 
            camera.position.set((1 - mazeSize / 2) * TILE_SIZE, 8, (1 - mazeSize / 2) * TILE_SIZE);
            camera.rotation.y = Math.PI;

            let ex = mazeSize-2, ey = mazeSize-2;
            if(maze[ey][ex]===1) { ex=1; ey=mazeSize-2; }
            exitPosition.set((ex-mazeSize/2)*TILE_SIZE, 0, (ey-mazeSize/2)*TILE_SIZE);

            const exitGeo = new THREE.BoxGeometry(4, 100, 4);
            const exitMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.6 });
            const exitMark = new THREE.Mesh(exitGeo, exitMat);
            exitMark.position.copy(exitPosition); exitMark.position.y=50;
            worldGroup.add(exitMark);
        }

        function checkWinCondition() {
            const pos = camera.position;
            const dist = Math.hypot(pos.x - exitPosition.x, pos.z - exitPosition.z);
            if(dist < 10) gameOver(true, "éé—œï¼");
        }

        function gameOver(win, message) {
            gameActive = false;
            clearInterval(timerInterval);
            const screen = document.getElementById('result-screen');
            const title = document.getElementById('result-title');
            const msg = document.getElementById('result-message');
            const btn = document.getElementById('action-btn');
            
            screen.style.display = 'flex';
            msg.innerText = message;

            if (win) {
                soundManager.playWin();
                if (currentLevelIndex + 1 >= LEVELS.length) {
                    title.innerText = "ğŸ† ç”Ÿå­˜å¤§å¸«ï¼";
                    title.className = "win-text";
                    btn.innerText = "å›åˆ°ä¸»é¸å–®";
                    btn.className = "action-btn btn-next";
                    btn.onclick = () => location.reload();
                } else {
                    title.innerText = "ğŸ‰ é€ƒè„«æˆåŠŸï¼";
                    title.className = "win-text";
                    btn.innerText = "ä¸‹ä¸€é—œ >>";
                    btn.className = "action-btn btn-next";
                }
            } else {
                soundManager.playLose();
                title.innerText = "ğŸ’€ ä»»å‹™å¤±æ•—";
                title.className = "lose-text";
                btn.innerText = "é‡è©¦æœ¬é—œ";
                btn.className = "action-btn btn-retry";
            }
        }

        function checkCollision(pos) {
            const pX = pos.x; const pZ = pos.z; const r = 1.5; 
            const checks = [{x:pX+r, z:pZ}, {x:pX-r, z:pZ}, {x:pX, z:pZ+r}, {x:pX, z:pZ-r}];
            const ms = currentLevelData.size;
            for (let p of checks) {
                const gx = Math.round((p.x / TILE_SIZE) + (ms / 2));
                const gy = Math.round((p.z / TILE_SIZE) + (ms / 2));
                if (gx >= 0 && gx < ms && gy >= 0 && gy < ms) {
                    if (maze[gy][gx] === 1) return true;
                }
            }
            return false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1); 
            prevTime = time;

            if (gameActive) {
                // ç„¡æ•µæ™‚é–“å€’æ•¸
                if (playerStats.invincible > 0) playerStats.invincible -= delta;

                // ç‰©ç†æ›´æ–°
                updateProjectiles(delta);
                updateEnemies(delta);
                updateItems(delta);

                // ç©å®¶ç§»å‹•
                if (rotateLeft) camera.rotation.y += ROTATE_SPEED * delta;
                if (rotateRight) camera.rotation.y -= ROTATE_SPEED * delta;

                let moveSpeed = 0;
                const finalSpeed = PLAYER_BASE_SPEED * playerStats.speedMulti;
                
                if (moveForward) moveSpeed = finalSpeed * delta;
                if (moveBackward) moveSpeed = -finalSpeed * delta;

                if (moveSpeed !== 0) {
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    forward.y = 0; forward.normalize();
                    const currentPos = camera.position.clone();
                    const nextX = currentPos.x + forward.x * moveSpeed;
                    const nextZ = currentPos.z + forward.z * moveSpeed;

                    if (!checkCollision(new THREE.Vector3(nextX, currentPos.y, currentPos.z))) camera.position.x = nextX;
                    if (!checkCollision(new THREE.Vector3(camera.position.x, currentPos.y, nextZ))) camera.position.z = nextZ;
                }
                checkWinCondition();
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
