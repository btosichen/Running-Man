<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <!-- é—œéµï¼šç¦æ­¢ç¸®æ”¾ï¼Œç¢ºä¿æ‰‹æ©Ÿç‰ˆæ“ä½œç©©å®š -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D æ ¡åœ’è¿·å®®é€ƒè„« (æ‰‹æ©Ÿé™æ§ä¿®å¾©ç‰ˆ)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #000;
            user-select: none;
            -webkit-user-select: none;
            /* ç¦æ­¢è§¸æ§é è¨­è¡Œç‚º (å¦‚é•·æŒ‰é¸å–ã€ä¸‹æ‹‰é‡æ•´) */
            touch-action: none; 
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
        }

        /* éŠæˆ²å®¹å™¨ï¼šå¼·åˆ¶ 16:9 */
        #game-container {
            position: relative;
            width: 100%;
            /* ç¢ºä¿ä¸è¶…éè¢å¹•é‚Šç•Œï¼Œä¸¦ä¿æŒ 16:9 */
            max-width: 100vw; 
            max-height: 100vh;
            aspect-ratio: 16/9;
            background-color: #87CEEB;
            overflow: hidden;
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.1);
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 5;
        }

        /* --- è§¸æ§ä»‹é¢å±¤ (å¤§å¹…å„ªåŒ–) --- */
        #mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
            /* ä½¿ç”¨ Flexbox è®“å·¦å³æ§åˆ¶å€åˆ†é–‹ */
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            /* å…§ç¸®è·é›¢ï¼Œé¿å…å¤ªè²¼é‚Š */
            padding: 4vmin; 
            box-sizing: border-box;
        }

        .control-zone {
            pointer-events: auto;
            position: relative;
        }

        /* å·¦å´ D-Pad ç¶²æ ¼ */
        .d-pad-grid {
            display: grid;
            /* ä½¿ç”¨ vmin å–®ä½ï¼Œéš¨è¢å¹•çŸ­é‚Šç¸®æ”¾ */
            grid-template-columns: 12vmin 12vmin 12vmin;
            grid-template-rows: 12vmin 12vmin 12vmin;
            gap: 1vmin;
        }

        .touch-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 15px;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 6vmin; /* å­—é«”éš¨æŒ‰éˆ•å¤§å°ç¸®æ”¾ */
            font-weight: bold;
            backdrop-filter: blur(4px);
            transition: background 0.1s, transform 0.1s;
            /* é—œéµï¼šç¢ºä¿è§¸æ§ä¸å»¶é² */
            touch-action: manipulation; 
        }

        .touch-btn:active, .touch-btn.pressed {
            background: rgba(255, 200, 0, 0.7);
            border-color: rgba(255, 200, 0, 1);
            transform: scale(0.9);
        }

        /* D-Pad ä½ˆå±€å¾®èª¿ */
        .btn-up { grid-column: 2; grid-row: 1; }
        .btn-left { grid-column: 1; grid-row: 2; }
        .btn-down { grid-column: 2; grid-row: 3; }
        .btn-right { grid-column: 3; grid-row: 2; }

        /* å³å´ æŠ€èƒ½éµ */
        .action-zone {
            /* ç¨å¾®å¾€ä¸ŠæŠ¬ä¸€é»ï¼Œç¬¦åˆå¤§æ‹‡æŒ‡ä½ç½® */
            margin-bottom: 4vmin;
            margin-right: 2vmin;
        }

        .btn-skill {
            width: 18vmin; /* å¤§å°é©ä¸­çš„åœ“å½¢æŒ‰éˆ• */
            height: 18vmin;
            border-radius: 50%;
            background: rgba(255, 50, 50, 0.4);
            border: 3px solid rgba(255, 100, 100, 0.7);
            font-size: 8vmin;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
        }
        .btn-skill:active, .btn-skill.pressed {
            background: rgba(255, 50, 50, 0.9);
            transform: scale(0.9);
        }

        /* HUD å­—é«”èª¿æ•´ */
        #hud {
            padding: 2vmin;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            color: #fff;
            text-shadow: 2px 2px 0px #000;
            font-family: 'Arial Black', sans-serif;
            font-size: 3.5vmin; /* å­—é«”éš¨è¢å¹•ç¸®æ”¾ */
        }
        
        #health-container {
            width: 30vmin;
            height: 4vmin;
            background: #333;
            border: 0.5vmin solid #fff;
            border-radius: 2vmin;
            overflow: hidden;
            margin-top: 1vmin;
            position: relative;
        }
        #health-bar { width: 100%; height: 100%; background: #e74c3c; transition: width 0.2s; }
        #health-text {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            font-size: 2.5vmin; text-shadow: 1px 1px 0 #000;
        }

        #status-effects { margin-top: 1vmin; display: flex; gap: 1vmin; }
        .effect-badge {
            padding: 0.5vmin 1.5vmin; border-radius: 1vmin; font-size: 2.5vmin;
            font-weight: bold; text-shadow: 1px 1px 0 #000; animation: pulse 1s infinite;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        #input-debug { display: none; }

        #blocker {
            position: absolute; width: 100%; height: 100%; top: 0; left: 0;
            background-color: rgba(0,0,0,0.8); backdrop-filter: blur(5px);
            display: flex; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 30;
        }
        #instructions {
            width: 85%; max-width: 600px; padding: 5vmin;
            background: linear-gradient(135deg, #ffffff, #f0f0f0);
            border-radius: 3vmin; text-align: center; color: #333;
            box-shadow: 0 4vmin 10vmin rgba(0,0,0,0.5); border: 1vmin solid #fff;
        }
        h1 { margin: 0 0 2vmin 0; color: #c0392b; font-size: 6vmin; font-family: 'Arial Black', sans-serif; }
        p { font-size: 3.5vmin; margin: 1.5vmin 0; color: #555; font-weight: bold; }
        
        #start-btn {
            background: #2ecc71; color: white; font-size: 5vmin; padding: 2vmin 8vmin;
            border: none; border-radius: 2vmin; cursor: pointer; margin-top: 4vmin;
            box-shadow: 0 1vmin 0 #27ae60; font-weight: 900; font-family: 'Arial Black', sans-serif;
            /* å¢åŠ æŒ‰éˆ•æ„Ÿæ‡‰å€åŸŸ */
            touch-action: manipulation;
        }
        #start-btn:active { transform: translateY(1vmin); box-shadow: 0 0 0 #27ae60; }

        #result-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 10, 10, 0.95); color: white; z-index: 40;
            flex-direction: column; align-items: center; justify-content: center;
            text-align: center; pointer-events: auto;
        }
        button.action-btn {
            padding: 2vmin 6vmin; font-size: 4vmin; color: white; border: none; border-radius: 2vmin;
            cursor: pointer; margin-top: 4vmin; box-shadow: 0 1vmin 0 rgba(0,0,0,0.2);
            transition: transform 0.1s; font-weight: bold; font-family: 'Arial Black', sans-serif;
        }
        .btn-next { background: #3498db; box-shadow: 0 1vmin 0 #2980b9; }
        .btn-retry { background: #e74c3c; box-shadow: 0 1vmin 0 #c0392b; }
        .btn-next:active, .btn-retry:active { transform: translateY(1vmin); box-shadow: none; }
        
        .win-text { color: #2ecc71; font-size: 8vmin; text-shadow: 0.5vmin 0.5vmin 0 #27ae60; font-family: 'Arial Black', sans-serif; }
        .lose-text { color: #e74c3c; font-size: 8vmin; text-shadow: 0.5vmin 0.5vmin 0 #c0392b; font-family: 'Arial Black', sans-serif; }
        .warning-text { color: #f39c12; font-size: 3vmin; margin-top: 1vmin; display: none; font-weight: bold; text-shadow: 1px 1px 0 #000; }
    </style>
</head>
<body>

    <!-- éŠæˆ²ä¸»å®¹å™¨ (16:9) -->
    <div id="game-container">
        
        <!-- HUD -->
        <div id="ui-layer">
            <div id="hud">
                <div>
                    <div style="color: #f1c40f;">Level <span id="level-num">1</span> / 100</div>
                    <div id="time-display">â° 05:00</div>
                    <div id="status-effects"></div>
                    <div id="enemy-warning" class="warning-text">âš ï¸ æ•µäººç‹‚æš´åŒ–ï¼</div>
                </div>
                <div style="text-align: right;">
                    <div id="status">å°‹æ‰¾ç¶ è‰²å…‰æŸ±</div>
                    <div id="health-container">
                        <div id="health-bar"></div>
                        <div id="health-text">HP: 100/100</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- æ‰‹æ©Ÿè§¸æ§å±¤ -->
        <div id="mobile-controls">
            <div class="control-zone d-pad-grid">
                <div class="touch-btn btn-up" id="btn-up">â–²</div>
                <div class="touch-btn btn-left" id="btn-left">â—€</div>
                <div class="touch-btn btn-down" id="btn-down">â–¼</div>
                <div class="touch-btn btn-right" id="btn-right">â–¶</div>
            </div>
            <div class="control-zone action-zone">
                <div class="touch-btn btn-skill" id="btn-skill">ğŸ’¥</div>
            </div>
        </div>

        <!-- é–‹å§‹ç•«é¢ -->
        <div id="blocker">
            <div id="instructions">
                <h1 id="menu-title">æ ¡åœ’ç”Ÿå­˜é€ƒè„«</h1>
                <p id="menu-subtitle">100 å±¤ç„¡ç›¡æŒ‘æˆ°ï¼(æ‰‹æ©Ÿç‰ˆ)</p>
                <hr style="border: 2px dashed #ddd; margin: 2vmin 0;">
                <p>å·¦æ‰‹æ–¹å‘ &nbsp; å³æ‰‹é­”æ³•</p>
                <p>âš¡åŠ é€Ÿ &nbsp; â„ï¸ç·©é€Ÿ &nbsp; â¤ï¸è£œè¡€</p>
                <br>
                <!-- åŒæ™‚ç›£è½ touchstart å’Œ click -->
                <button id="start-btn">é»æ“Šé–‹å§‹</button>
            </div>
        </div>

        <!-- çµç®—ç•«é¢ -->
        <div id="result-screen">
            <div id="result-title" class="win-text"></div>
            <p id="result-message" style="font-size: 4vmin; margin: 4vmin; color: #ddd; font-weight: bold;"></p>
            <button id="action-btn" class="action-btn" onclick="handleAction()">ä¸‹ä¸€é—œ</button>
        </div>

    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- å…¨åŸŸè®Šæ•¸ ---
        let camera, scene, renderer;
        let worldGroup = new THREE.Group();
        
        let playerStats = { hp: 100, maxHp: 100, speedMulti: 1.0, invincible: 0 };
        const PLAYER_BASE_SPEED = 250.0;
        const ROTATE_SPEED = 2.5;
        let weaponMesh;
        let projectiles = [];
        
        // æ§åˆ¶æ——æ¨™
        let moveForward = false, moveBackward = false, rotateLeft = false, rotateRight = false;
        
        let enemies = [];
        let items = [];
        let maze = [];
        let exitPosition = new THREE.Vector3();
        
        let prevTime = performance.now();
        const TILE_SIZE = 25;
        const WALL_HEIGHT = 20;
        let gameActive = false;
        let timeLeft = 0;
        let timerInterval;
        let enemySpeedMulti = 1.0;

        let currentLevel = 1;
        let currentLevelData = {};

        // --- éŸ³æ•ˆç®¡ç†å™¨ ---
        class SoundManager {
            constructor() { 
                this.ctx = null; 
                this.bgmTimer = null;
                this.bgmNoteIndex = 0;
                this.isPlaying = false;
            }
            init() {
                try {
                    if(!this.ctx) {
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        this.ctx = new AudioContext();
                    }
                    if(this.ctx.state === 'suspended') this.ctx.resume();
                    this.isPlaying = true;
                    this.startBGM();
                } catch (e) {
                    console.log("Audio init failed (safely ignored):", e);
                }
            }
            stop() {
                this.isPlaying = false;
                if(this.bgmTimer) clearTimeout(this.bgmTimer);
            }
            playTone(freq, type, duration, vol = 0.1) {
                if (!this.ctx) return;
                try {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                    gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                    osc.connect(gain); gain.connect(this.ctx.destination);
                    osc.start(); osc.stop(this.ctx.currentTime + duration);
                } catch(e) {}
            }
            playNoise(duration, vol) {
                if (!this.ctx) return;
                try {
                    const bufferSize = this.ctx.sampleRate * duration;
                    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                    const noise = this.ctx.createBufferSource();
                    noise.buffer = buffer;
                    const gain = this.ctx.createGain();
                    gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                    noise.connect(gain); gain.connect(this.ctx.destination);
                    noise.start();
                } catch(e) {}
            }
            
            startBGM() {
                if (!this.ctx) return;
                if (this.bgmTimer) clearTimeout(this.bgmTimer);
                const bassLine = [110, 0, 110, 0, 146, 0, 130, 0];
                const leadLine = [440, 523, 587, 659, 523, 587, 440, 392];
                const tempo = 220;
                const playStep = () => {
                    if (!this.isPlaying) return;
                    const idx = this.bgmNoteIndex % 8;
                    if (bassLine[idx] > 0) this.playTone(bassLine[idx], 'sawtooth', 0.1, 0.1);
                    if (Math.random() > 0.2) this.playTone(leadLine[idx], 'square', 0.1, 0.03);
                    if (idx % 4 === 0) this.playNoise(0.05, 0.05);
                    if (idx % 2 === 0) this.playNoise(0.01, 0.02);
                    this.bgmNoteIndex++;
                    this.bgmTimer = setTimeout(playStep, tempo);
                };
                playStep();
            }

            playShoot() { this.playTone(600, 'square', 0.1, 0.1); setTimeout(()=>this.playTone(300, 'square', 0.1, 0.1), 50); }
            playEnemyShoot() { this.playTone(200, 'sawtooth', 0.1, 0.1); }
            playHit() { this.playNoise(0.1, 0.2); }
            playPowerUp() { this.playTone(1000, 'sine', 0.2, 0.2); setTimeout(()=>this.playTone(1500, 'sine', 0.3, 0.2), 100); }
            playDamage() { this.playTone(100, 'sawtooth', 0.3, 0.3); }
            playWin() { this.stop(); [523, 659, 784, 1046].forEach((f,i)=>setTimeout(()=>this.playTone(f,'square',0.2,0.2),i*100)); }
            playLose() { this.stop(); this.playTone(200,'sawtooth',0.5,0.3); setTimeout(()=>this.playTone(100,'sawtooth',1.0,0.3),400); }
        }
        const soundManager = new SoundManager();

        window.handleAction = function() {
            const btn = document.getElementById('action-btn');
            const resultScreen = document.getElementById('result-screen');
            if (btn.classList.contains('btn-next')) {
                currentLevel++;
                if (currentLevel > 100) {
                    location.reload();
                } else {
                    resultScreen.style.display = 'none';
                    startLevel(currentLevel);
                }
            } else {
                resultScreen.style.display = 'none';
                startLevel(currentLevel);
            }
        };

        init();
        animate();

        function init() {
            const container = document.getElementById('game-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 250);

            camera = new THREE.PerspectiveCamera(75, 16 / 9, 1, 1000);
            camera.rotation.order = 'YXZ'; 

            const weaponGeo = new THREE.BoxGeometry(0.5, 0.5, 4);
            const weaponMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            weaponMesh = new THREE.Mesh(weaponGeo, weaponMat);
            weaponMesh.position.set(1.5, -1.5, -2);
            weaponMesh.rotation.x = -0.2;
            weaponMesh.rotation.y = -0.2;
            camera.add(weaponMesh);
            scene.add(camera);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
            sunLight.position.set(100, 200, 100);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048; sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.left = -300; sunLight.shadow.camera.right = 300;
            sunLight.shadow.camera.top = 300; sunLight.shadow.camera.bottom = -300;
            scene.add(sunLight);
            scene.add(worldGroup);

            // å•Ÿå‹•æŒ‰éˆ•é‚è¼¯ (ä¿®å¾©æ‰‹æ©Ÿç„¡åæ‡‰)
            const startBtn = document.getElementById('start-btn');
            const startGame = (e) => {
                e.preventDefault(); // é˜²æ­¢è§¸ç™¼å…©æ¬¡
                e.stopPropagation();
                document.getElementById('blocker').style.display = 'none';
                soundManager.init();
                startLevel(1);
            };
            
            startBtn.addEventListener('touchstart', startGame, { passive: false });
            startBtn.addEventListener('click', startGame); // å‚™ç”¨ï¼Œçµ¦é›»è…¦ç‰ˆ

            // --- è§¸æ§äº‹ä»¶ç¶å®š ---
            const bindTouch = (id, startAction, endAction) => {
                const btn = document.getElementById(id);
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault(); 
                    startAction();
                    btn.classList.add('pressed');
                }, { passive: false });
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    endAction();
                    btn.classList.remove('pressed');
                }, { passive: false });
                // PC æ¸¬è©¦ç”¨
                btn.addEventListener('mousedown', () => { startAction(); btn.classList.add('pressed'); });
                btn.addEventListener('mouseup', () => { endAction(); btn.classList.remove('pressed'); });
                btn.addEventListener('mouseleave', () => { endAction(); btn.classList.remove('pressed'); });
            };

            bindTouch('btn-up', () => moveForward = true, () => moveForward = false);
            bindTouch('btn-down', () => moveBackward = true, () => moveBackward = false);
            bindTouch('btn-left', () => rotateLeft = true, () => rotateLeft = false);
            bindTouch('btn-right', () => rotateRight = true, () => rotateRight = false);
            bindTouch('btn-skill', () => shoot(), () => {});

            // --- éµç›¤äº‹ä»¶ ---
            const onKeyDown = (e) => {
                const k = e.key.toLowerCase(), c = e.code;
                if(c==='ArrowUp'||c==='KeyW'||k==='w') { moveForward=true; document.getElementById('btn-up').classList.add('pressed'); }
                if(c==='ArrowDown'||c==='KeyS'||k==='s') { moveBackward=true; document.getElementById('btn-down').classList.add('pressed'); }
                if(c==='ArrowLeft'||c==='KeyA'||k==='a') { rotateLeft=true; document.getElementById('btn-left').classList.add('pressed'); }
                if(c==='ArrowRight'||c==='KeyD'||k==='d') { rotateRight=true; document.getElementById('btn-right').classList.add('pressed'); }
                if(c==='Space'||k===' ') { shoot(); document.getElementById('btn-skill').classList.add('pressed'); }
            };
            const onKeyUp = (e) => {
                const k = e.key.toLowerCase(), c = e.code;
                if(c==='ArrowUp'||c==='KeyW'||k==='w') { moveForward=false; document.getElementById('btn-up').classList.remove('pressed'); }
                if(c==='ArrowDown'||c==='KeyS'||k==='s') { moveBackward=false; document.getElementById('btn-down').classList.remove('pressed'); }
                if(c==='ArrowLeft'||c==='KeyA'||k==='a') { rotateLeft=false; document.getElementById('btn-left').classList.remove('pressed'); }
                if(c==='ArrowRight'||c==='KeyD'||k==='d') { rotateRight=false; document.getElementById('btn-right').classList.remove('pressed'); }
                if(c==='Space'||k===' ') { document.getElementById('btn-skill').classList.remove('pressed'); }
            };
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(width, height);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            window.addEventListener('resize', onWindowResize);
        }

        // --- éŠæˆ²é‚è¼¯ ---
        function getLevelData(level) {
            let size = 15 + Math.floor((level - 1) / 2) * 2;
            if (size > 61) size = 61;
            let enemies = Math.floor(3 + level * 0.8);
            let time = 300 + (level * 10);
            return { id: level, size: size, time: time, enemies: enemies };
        }

        function startLevel(level) {
            currentLevel = level;
            currentLevelData = getLevelData(level);

            while(worldGroup.children.length > 0) worldGroup.remove(worldGroup.children[0]);
            enemies = [];
            items = [];
            projectiles = [];
            
            playerStats.hp = playerStats.maxHp;
            playerStats.speedMulti = 1.0;
            playerStats.invincible = 0;
            enemySpeedMulti = 1.0;
            updateHPBar();
            updateStatusEffects();

            document.getElementById('level-num').innerText = currentLevel;
            const warning = document.getElementById('enemy-warning');
            if(currentLevel >= 3) {
                warning.style.display = 'block';
                warning.innerText = `âš ï¸ Level ${currentLevel}: æ•µäººæ”»æ“Šèˆ‡é‡ç”Ÿï¼`;
            } else {
                warning.style.display = 'none';
            }

            timeLeft = currentLevelData.time;
            updateTimeDisplay();

            createMazeWorld(currentLevelData.size);
            
            for(let i=0; i<currentLevelData.enemies; i++) {
                spawnSingleEnemy();
            }
            spawnItems(5 + Math.floor(currentLevel/5)); 

            moveForward = false; moveBackward = false; rotateLeft = false; rotateRight = false;
            prevTime = performance.now();
            gameActive = true;
            
            soundManager.isPlaying = true;
            soundManager.startBGM();

            if(timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if(!gameActive) return;
                timeLeft--;
                updateTimeDisplay();
                if(timeLeft <= 0) gameOver(false, "æ™‚é–“è€—ç›¡ï¼");
            }, 1000);
        }

        function updateTimeDisplay() {
            const m = Math.floor(timeLeft/60).toString().padStart(2,'0');
            const s = (timeLeft%60).toString().padStart(2,'0');
            document.getElementById('time-display').innerText = `â° ${m}:${s}`;
        }

        function shoot() {
            if(!gameActive) return;
            soundManager.playShoot();
            weaponMesh.position.z = -1; 
            setTimeout(() => weaponMesh.position.z = -2, 100);

            const sphereGeo = new THREE.SphereGeometry(0.5, 8, 8);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(sphereGeo, sphereMat);
            
            const pos = new THREE.Vector3();
            const quat = new THREE.Quaternion();
            camera.getWorldPosition(pos);
            camera.getWorldQuaternion(quat);
            
            const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(quat).normalize();
            bullet.position.copy(pos).add(dir.clone().multiplyScalar(2));
            
            bullet.userData = { velocity: dir.multiplyScalar(60), life: 2.0, isEnemy: false };
            worldGroup.add(bullet);
            projectiles.push(bullet);
        }

        function enemyShoot(enemy) {
            if(!gameActive) return;
            soundManager.playEnemyShoot();
            
            const sphereGeo = new THREE.SphereGeometry(0.8, 8, 8);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const bullet = new THREE.Mesh(sphereGeo, sphereMat);
            
            const startPos = enemy.mesh.position.clone();
            const targetPos = camera.position.clone();
            targetPos.y -= 2;
            
            const dir = new THREE.Vector3().subVectors(targetPos, startPos).normalize();
            bullet.position.copy(startPos).add(dir.clone().multiplyScalar(4));
            
            bullet.userData = { velocity: dir.multiplyScalar(30), life: 3.0, isEnemy: true };
            worldGroup.add(bullet);
            projectiles.push(bullet);
        }

        function spawnSingleEnemy() {
            const geo = new THREE.BoxGeometry(7, 7, 7);
            const mat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const eyeGeo = new THREE.BoxGeometry(1.0, 1.0, 0.5);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });

            let x, z;
            let attempts = 0;
            do {
                x = Math.floor(Math.random() * currentLevelData.size);
                z = Math.floor(Math.random() * currentLevelData.size);
                attempts++;
            } while (maze[z][x] === 1 && attempts < 100);

            if (maze[z][x] === 0) {
                const group = new THREE.Group();
                const body = new THREE.Mesh(geo, mat);
                const eyeL = new THREE.Mesh(eyeGeo, eyeMat); eyeL.position.set(-1.8, 1.0, 3.6);
                const eyeR = new THREE.Mesh(eyeGeo, eyeMat); eyeR.position.set(1.8, 1.0, 3.6);
                group.add(body, eyeL, eyeR);
                
                const px = (x - currentLevelData.size/2) * TILE_SIZE;
                const pz = (z - currentLevelData.size/2) * TILE_SIZE;
                group.position.set(px, 3.5, pz);
                group.castShadow = true;

                worldGroup.add(group);
                enemies.push({ 
                    mesh: group, 
                    hp: 3, 
                    speed: 15 + Math.random() * 10,
                    lastShot: 0
                });
            }
        }

        function spawnItems(count) {
            const geo = new THREE.BoxGeometry(2, 2, 2);
            const colors = [0xffff00, 0x00ffff, 0xff0000];
            const types = ['speed', 'slow', 'heal'];

            for(let i=0; i<count; i++) {
                let x, z;
                let attempts = 0;
                do {
                    x = Math.floor(Math.random() * currentLevelData.size);
                    z = Math.floor(Math.random() * currentLevelData.size);
                    attempts++;
                } while (maze[z][x] === 1 && attempts < 100);

                if (maze[z][x] === 0) {
                    const typeIdx = Math.floor(Math.random() * 3);
                    const mat = new THREE.MeshStandardMaterial({ 
                        color: colors[typeIdx], emissive: colors[typeIdx], emissiveIntensity: 0.5 
                    });
                    const item = new THREE.Mesh(geo, mat);
                    const px = (x - currentLevelData.size/2) * TILE_SIZE;
                    const pz = (z - currentLevelData.size/2) * TILE_SIZE;
                    item.position.set(px, 4, pz);
                    worldGroup.add(item);
                    items.push({ mesh: item, type: types[typeIdx] });
                }
            }
        }

        function updateProjectiles(dt) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const b = projectiles[i];
                const move = b.userData.velocity.clone().multiplyScalar(dt);
                b.position.add(move);
                b.userData.life -= dt;

                let hit = false;
                if (checkCollision(b.position)) hit = true;

                if (!hit) {
                    if (b.userData.isEnemy) {
                        const playerPos = camera.position;
                        if (b.position.distanceTo(playerPos) < 4) {
                            takeDamage(15);
                            hit = true;
                        }
                    } else {
                        for (let j = enemies.length - 1; j >= 0; j--) {
                            const enemy = enemies[j];
                            if (b.position.distanceTo(enemy.mesh.position) < 6) {
                                soundManager.playHit();
                                enemy.hp--;
                                const pushDir = b.userData.velocity.clone().normalize().multiplyScalar(5);
                                enemy.mesh.position.add(pushDir);
                                
                                if (enemy.hp <= 0) {
                                    worldGroup.remove(enemy.mesh);
                                    enemies.splice(j, 1);
                                    if(currentLevel >= 3) {
                                        setTimeout(() => { if(gameActive) spawnSingleEnemy(); }, 3000);
                                    }
                                } else {
                                    enemy.mesh.children[0].material.emissive.setHex(0xff0000);
                                    setTimeout(()=>enemy.mesh.children[0].material.emissive.setHex(0x000000), 100);
                                }
                                hit = true;
                                break;
                            }
                        }
                    }
                }

                if (hit || b.userData.life <= 0) {
                    worldGroup.remove(b);
                    projectiles.splice(i, 1);
                }
            }
        }

        function updateEnemies(dt, now) {
            const playerPos = camera.position;
            enemies.forEach(e => {
                e.mesh.lookAt(playerPos.x, e.mesh.position.y, playerPos.z);
                const dist = e.mesh.position.distanceTo(playerPos);
                
                if (dist < 120) { 
                    const dir = new THREE.Vector3().subVectors(playerPos, e.mesh.position).normalize();
                    dir.y = 0;
                    
                    const moveDist = e.speed * enemySpeedMulti * dt;
                    const nextPos = e.mesh.position.clone().add(dir.multiplyScalar(moveDist));
                    
                    if (!checkCollision(nextPos)) e.mesh.position.copy(nextPos);
                    
                    if (dist < 6) {
                        takeDamage(10);
                        e.mesh.position.sub(dir.multiplyScalar(8)); 
                    }

                    if (currentLevel >= 3 && now - e.lastShot > 2000 && dist < 80) { 
                        enemyShoot(e);
                        e.lastShot = now;
                    }
                }
                e.mesh.scale.setScalar(1 + Math.sin(now * 0.01) * 0.1);
            });
        }

        function updateItems(dt) {
            const playerPos = camera.position;
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                item.mesh.rotation.y += dt;
                item.mesh.position.y = 4 + Math.sin(Date.now() * 0.005);

                const dx = item.mesh.position.x - playerPos.x;
                const dz = item.mesh.position.z - playerPos.z;
                const dist2d = Math.sqrt(dx*dx + dz*dz);

                if (dist2d < 6) { 
                    applyEffect(item.type);
                    worldGroup.remove(item.mesh);
                    items.splice(i, 1);
                }
            }
        }

        function takeDamage(amount) {
            if (playerStats.invincible > 0) return;
            playerStats.hp -= amount;
            soundManager.playDamage();
            updateHPBar();
            scene.background = new THREE.Color(0x550000);
            setTimeout(() => scene.background = new THREE.Color(0x87CEEB), 100);
            playerStats.invincible = 1.0; 
            if (playerStats.hp <= 0) gameOver(false, "ä½ å€’ä¸‹äº†ï¼");
        }

        function applyEffect(type) {
            soundManager.playPowerUp();
            
            if (type === 'heal') {
                playerStats.hp = Math.min(playerStats.hp + 30, playerStats.maxHp);
                updateHPBar();
            } else if (type === 'speed') {
                playerStats.speedMulti = 1.8;
                setTimeout(() => { playerStats.speedMulti = 1.0; updateStatusEffects(); }, 8000);
            } else if (type === 'slow') {
                enemySpeedMulti = 0.3;
                setTimeout(() => { enemySpeedMulti = 1.0; updateStatusEffects(); }, 8000);
            }
            updateStatusEffects();
        }

        function updateStatusEffects() {
            const div = document.getElementById('status-effects');
            div.innerHTML = '';
            if (playerStats.speedMulti > 1) div.innerHTML += '<div class="effect-badge" style="background:#f1c40f; color:#000;">âš¡åŠ é€Ÿä¸­</div>';
            if (enemySpeedMulti < 1) div.innerHTML += '<div class="effect-badge" style="background:#3498db; color:#fff;">â„ï¸å‡çµä¸­</div>';
        }

        function updateHPBar() {
            const bar = document.getElementById('health-bar');
            const txt = document.getElementById('health-text');
            const pct = Math.max(0, (playerStats.hp / playerStats.maxHp) * 100);
            bar.style.width = pct + '%';
            txt.innerText = `HP: ${playerStats.hp}/${playerStats.maxHp}`;
        }

        function createBrickTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#a0a0a0'; ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#c0392b';
            for(let y=0; y<128; y+=18) {
                const off = (y/18)%2===0?0:16;
                for(let x=-16; x<128; x+=34) ctx.fillRect(x+off, y, 32, 16);
            }
            ctx.fillStyle = '#87CEEB'; ctx.fillRect(32,32,64,64);
            ctx.strokeStyle='#fff'; ctx.lineWidth=4; ctx.strokeRect(32,32,64,64);
            return new THREE.CanvasTexture(canvas);
        }

        function createPaverTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d'); ctx.fillStyle = '#7f8c8d'; ctx.fillRect(0,0,64,64);
            ctx.strokeStyle = '#636e72'; ctx.strokeRect(0,0,64,64);
            return new THREE.CanvasTexture(canvas);
        }

        function createMazeWorld(mazeSize) {
            maze = Array(mazeSize).fill().map(() => Array(mazeSize).fill(1));
            function carve(x, y) {
                const dirs = [[1,0], [-1,0], [0,1], [0,-1]].sort(() => Math.random()-0.5);
                dirs.forEach(([dx, dy]) => {
                    const nx = x + dx*2, ny = y + dy*2;
                    if (nx > 0 && nx < mazeSize-1 && ny > 0 && ny < mazeSize-1 && maze[ny][nx] === 1) {
                        maze[y+dy][x+dx] = 0; maze[ny][nx] = 0; carve(nx, ny);
                    }
                });
            }
            maze[1][1] = 0; carve(1,1);

            const floorSize = mazeSize * TILE_SIZE * 1.5;
            const floorMat = new THREE.MeshStandardMaterial({ map: createPaverTexture(), roughness: 0.8 });
            floorMat.map.repeat.set(floorSize/20, floorSize/20); floorMat.map.wrapS = floorMat.map.wrapT = THREE.RepeatWrapping;
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(floorSize, floorSize), floorMat);
            floor.rotation.x = -Math.PI/2; floor.receiveShadow = true;
            worldGroup.add(floor);

            const boxGeo = new THREE.BoxGeometry(TILE_SIZE, WALL_HEIGHT, TILE_SIZE);
            const wallMat = new THREE.MeshStandardMaterial({ map: createBrickTexture() });

            for(let y=0; y<mazeSize; y++){
                for(let x=0; x<mazeSize; x++){
                    const px = (x - mazeSize/2) * TILE_SIZE;
                    const pz = (y - mazeSize/2) * TILE_SIZE;
                    if(maze[y][x] === 1) {
                        const wall = new THREE.Mesh(boxGeo, wallMat);
                        wall.position.set(px, WALL_HEIGHT/2, pz);
                        wall.castShadow = true; wall.receiveShadow = true;
                        worldGroup.add(wall);
                    }
                }
            }

            maze[1][1] = 0; 
            camera.position.set((1 - mazeSize / 2) * TILE_SIZE, 8, (1 - mazeSize / 2) * TILE_SIZE);
            camera.rotation.y = Math.PI;

            let ex = mazeSize-2, ey = mazeSize-2;
            if(maze[ey][ex]===1) { ex=1; ey=mazeSize-2; }
            exitPosition.set((ex-mazeSize/2)*TILE_SIZE, 0, (ey-mazeSize/2)*TILE_SIZE);

            const exitGeo = new THREE.BoxGeometry(4, 100, 4);
            const exitMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.6 });
            const exitMark = new THREE.Mesh(exitGeo, exitMat);
            exitMark.position.copy(exitPosition); exitMark.position.y=50;
            worldGroup.add(exitMark);
        }

        function checkWinCondition() {
            const pos = camera.position;
            const dist = Math.hypot(pos.x - exitPosition.x, pos.z - exitPosition.z);
            if(dist < 10) gameOver(true, "éé—œï¼");
        }

        function gameOver(win, message) {
            gameActive = false;
            clearInterval(timerInterval);
            const screen = document.getElementById('result-screen');
            const title = document.getElementById('result-title');
            const msg = document.getElementById('result-message');
            const btn = document.getElementById('action-btn');
            
            screen.style.display = 'flex';
            msg.innerText = message;

            if (win) {
                soundManager.playWin();
                if (currentLevel >= 100) {
                    title.innerText = "ğŸ† å‚³å¥‡èª•ç”Ÿï¼";
                    title.className = "win-text";
                    msg.innerText = "ä½ å¾æœäº† 100 å±¤è¿·å®®ï¼";
                    btn.innerText = "é‡æ–°é–‹å§‹";
                    btn.className = "action-btn btn-next";
                } else {
                    title.innerText = "ğŸ‰ é€ƒè„«æˆåŠŸï¼";
                    title.className = "win-text";
                    btn.innerText = "ä¸‹ä¸€é—œ >>";
                    btn.className = "action-btn btn-next";
                }
            } else {
                soundManager.playLose();
                title.innerText = "ğŸ’€ ä»»å‹™å¤±æ•—";
                title.className = "lose-text";
                btn.innerText = "é‡è©¦æœ¬é—œ";
                btn.className = "action-btn btn-retry";
            }
        }

        function checkCollision(pos) {
            const pX = pos.x; const pZ = pos.z; const r = 1.5; 
            const checks = [{x:pX+r, z:pZ}, {x:pX-r, z:pZ}, {x:pX, z:pZ+r}, {x:pX, z:pZ-r}];
            const ms = currentLevelData.size;
            for (let p of checks) {
                const gx = Math.round((p.x / TILE_SIZE) + (ms / 2));
                const gy = Math.round((p.z / TILE_SIZE) + (ms / 2));
                if (gx >= 0 && gx < ms && gy >= 0 && gy < ms) {
                    if (maze[gy][gx] === 1) return true;
                }
            }
            return false;
        }

        function onWindowResize() {
            const container = document.getElementById('game-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1); 
            prevTime = time;

            if (gameActive) {
                if (playerStats.invincible > 0) playerStats.invincible -= delta;

                updateProjectiles(delta);
                updateEnemies(delta, time);
                updateItems(delta);

                if (rotateLeft) camera.rotation.y += ROTATE_SPEED * delta;
                if (rotateRight) camera.rotation.y -= ROTATE_SPEED * delta;

                let moveSpeed = 0;
                const finalSpeed = PLAYER_BASE_SPEED * playerStats.speedMulti;
                
                if (moveForward) moveSpeed = finalSpeed * delta;
                if (moveBackward) moveSpeed = -finalSpeed * delta;

                if (moveSpeed !== 0) {
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    forward.y = 0; forward.normalize();
                    const currentPos = camera.position.clone();
                    const nextX = currentPos.x + forward.x * moveSpeed;
                    const nextZ = currentPos.z + forward.z * moveSpeed;

                    if (!checkCollision(new THREE.Vector3(nextX, currentPos.y, currentPos.z))) camera.position.x = nextX;
                    if (!checkCollision(new THREE.Vector3(camera.position.x, currentPos.y, nextZ))) camera.position.z = nextZ;
                }
                checkWinCondition();
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
